<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wedding Table Plan Creator</title>
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

</head>
<body>
  <div class="container-fluid">
    <!-- Top Controls (camera controls now use intuitive mouse actions) -->
    <div id="controls" class="no-print">
      <div class="row align-items-end">
        <div class="col-md-4">
          <label for="csv-file" class="form-label">Import Guest CSV (first column = name)</label>
          <input type="file" id="csv-file" accept=".csv" class="form-control">
        </div>
        <div class="col-md-8 text-end">
          <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newTableModal">
            New Table
          </button>
          <button type="button" class="btn btn-secondary ms-2" id="randomAssignBtn">Random Assign</button>
          <button type="button" class="btn btn-success ms-2" id="exportStateBtn">Export Plan</button>
          <button type="button" class="btn btn-info ms-2" id="importStateBtn">Import Plan</button>
          <button type="button" class="btn btn-warning ms-2" id="printPlanBtn">Print Plan</button>
          <!-- Hidden file input for JSON state import -->
          <input type="file" id="importStateFile" accept=".json" style="display:none;">
        </div>
      </div>
      <p class="text-muted mt-2">Use your mouse wheel to zoom. Click and drag on any blank area (i.e. not on a table) to pan the canvas.</p>
    </div>
    <div class="row">
        <!-- Left: Unassigned People Panel -->
        <div class="col-md-3">
        <div id="people-container">
            <h5>Unassigned Guests</h5>
          <!-- Guest/Seat counts -->
          <div id="guestSeatCounts"></div>
          <!-- Form to add a new guest -->
          <form id="addGuestForm" class="mb-3">
            <div class="input-group input-group-sm">
              <input type="text" id="newGuestName" class="form-control" placeholder="Add guest" required>
              <button class="btn btn-outline-primary" type="submit">Add</button>
            </div>
          </form>
          <input type="text" id="people-search-input" class="form-control mb-3" placeholder="Search guests">
          <div id="people-list"></div>
        </div>
      </div>
        
        <!-- Center: Table Plan Area -->
        <div class="col-md-6">
        <div id="table-plan" class="position-relative">
          <!-- The zoomable and pannable canvas -->
          <div id="canvas"></div>
        </div>
      </div>
        
        <!-- Right: Assigned Guests Section -->
        <div class="col-md-3">
          <div id="assigned-container">
            <h5>Assigned Guests</h5>
            <div id="assigned-guests-list"></div>
          </div>
        </div>
    </div>
  </div>

  <!-- Modal for Creating a New Table -->
  <div class="modal fade" id="newTableModal" tabindex="-1" aria-labelledby="newTableModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
         <div class="modal-header">
           <h5 class="modal-title" id="newTableModalLabel">Create New Table</h5>
           <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
         </div>
         <div class="modal-body">
           <form id="newTableForm">
             <div class="mb-3">
               <label for="tableName" class="form-label">Table Name</label>
               <input type="text" class="form-control" id="tableName" required>
             </div>
             <div class="mb-3">
               <label for="tableType" class="form-label">Table Type</label>
               <select class="form-select" id="tableType">
                 <option value="circle">Circle</option>
                 <option value="rectangle">Rectangle</option>
               </select>
             </div>
             <div class="mb-3">
               <label for="seatCount" class="form-label">Number of Seats</label>
               <input type="number" class="form-control" id="seatCount" value="8" min="1" required>
             </div>
             <button type="submit" class="btn btn-primary">Create Table</button>
           </form>
         </div>
      </div>
    </div>
  </div>

  <!-- Modal for Assigning a Guest to a Seat -->
  <div class="modal fade" id="assignmentModal" tabindex="-1" aria-labelledby="assignmentModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
         <div class="modal-header">
           <h5 class="modal-title" id="assignmentModalLabel">Assign Guest</h5>
           <button type="button" class="btn btn-danger" id="clearSeatBtn" style="display: none;     margin-left: 200px;">Clear Seat</button>
           <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
         </div>
         <div class="modal-body">
           <input type="text" id="assignmentSearch" class="form-control mb-3" placeholder="Search guests">
           <ul class="list-group" id="assignmentList"></ul>
         </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap Bundle JS (includes Popper) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- External CSS -->
  <link rel="stylesheet" href="styles.css">
  <!-- External JavaScript Modules -->
  <script src="js/canvas.js"></script>
  <script src="js/drag-drop.js"></script>
  <script>
    /* ============================
       Constants
    ============================ */
    const SEAT_R = 20; // half of .seat 40 px diameter
    
    /* ============================
       Guest (Person) Handling and Controls
    ============================ */
    let personCounter = 0;
    function addPerson(name) {
      personCounter++;
      const person = document.createElement('div');
      person.className = 'person';
      person.id = 'person-' + personCounter;
      person.draggable = true;
      person.addEventListener('dragstart', window.dragDropModule.handleDragStart);
      person.addEventListener('dragend', window.dragDropModule.handlePersonDragEnd);
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'guest-name';
      nameSpan.textContent = name;
      
      const controls = document.createElement('div');
      controls.className = 'guest-controls';
      const editBtn = document.createElement('button');
      editBtn.title = "Edit guest";
      editBtn.innerHTML = "âœŽ";
      editBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const currentName = nameSpan.textContent.replace(/[âœŽâœ–]/g, '').trim();
        const newName = prompt("Edit guest name:", currentName);
        if (newName && newName.trim() !== '') {
          nameSpan.textContent = newName.trim();
          // Update tooltips for this person
          updateTooltipsForPerson(person);
          updateCounts();
        }
      });
      controls.appendChild(editBtn);
      
      const removeBtn = document.createElement('button');
      removeBtn.title = "Remove guest";
      removeBtn.innerHTML = "âœ–";
      removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm("Remove this guest?")) {
          person.remove();
          updateCounts();
        }
      });
      controls.appendChild(removeBtn);
      
      person.appendChild(document.createElement('span')).innerHTML = '<span class="person-icon">ðŸ‘¤</span>';
      person.appendChild(nameSpan);
      person.appendChild(controls);
      document.getElementById('people-list').appendChild(person);
      updateCounts();
    }
    
    function createPersonElement(name) {
      personCounter++;
      const person = document.createElement('div');
      person.className = 'person';
      person.id = 'person-' + personCounter;
      person.draggable = true;
      person.addEventListener('dragstart', window.dragDropModule.handleDragStart);
      person.addEventListener('dragend', window.dragDropModule.handlePersonDragEnd);
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'guest-name';
      nameSpan.textContent = name;
      
      const controls = document.createElement('div');
      controls.className = 'guest-controls';
      const editBtn = document.createElement('button');
      editBtn.title = "Edit guest";
      editBtn.innerHTML = "âœŽ";
      editBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const currentName = nameSpan.textContent.replace(/[âœŽâœ–]/g, '').trim();
        const newName = prompt("Edit guest name:", currentName);
        if (newName && newName.trim() !== '') {
          nameSpan.textContent = newName.trim();
          // Update tooltips for this person
          updateTooltipsForPerson(person);
          updateCounts();
        }
      });
      controls.appendChild(editBtn);
      const removeBtn = document.createElement('button');
      removeBtn.title = "Remove guest";
      removeBtn.innerHTML = "âœ–";
      removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm("Remove this guest?")) {
          person.remove();
          updateCounts();
        }
      });
      controls.appendChild(removeBtn);
      
      person.appendChild(document.createElement('span')).innerHTML = '<span class="person-icon">ðŸ‘¤</span>';
      person.appendChild(nameSpan);
      person.appendChild(controls);
      return person;
    }
    
    /* ============================
       CSV Import for Guests
    ============================ */
    document.getElementById('csv-file').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const text = e.target.result;
        parseGuestCSV(text);
      }
      reader.readAsText(file);
    });
    function parseGuestCSV(text) {
      const lines = text.split('\n');
      lines.forEach(line => {
        if (line.trim() === '') return;
        const columns = line.split(',');
        const name = columns[0].trim();
        if (name) { addPerson(name); }
      });
    }
    
    /* ============================
       Search in Unassigned People
    ============================ */
    document.getElementById('people-search-input').addEventListener('input', function() {
      const query = this.value.toLowerCase();
      const persons = peopleList.getElementsByClassName('person');
      for (let person of persons) {
        person.style.display = person.textContent.toLowerCase().includes(query) ? 'flex' : 'none';
      }
    });
    
    /* ============================
       Tooltip Management
    ============================ */
    function cleanGuestName(person) {
      // Clean the guest name by removing edit button characters and ensuring proper structure
      const nameSpan = person.querySelector('.guest-name');
      if (nameSpan) {
        const currentText = nameSpan.textContent;
        const cleanName = currentText.replace(/[âœŽâœ–]/g, '').trim();
        if (currentText !== cleanName) {
          nameSpan.textContent = cleanName;
        }
      }
    }
    
    // Make cleanGuestName available globally
    window.cleanGuestName = cleanGuestName;
    
    // Function to clean all guest names in the unassigned list
    function cleanAllGuestNames() {
      const unassignedPersons = document.querySelectorAll('#people-list .person');
      unassignedPersons.forEach(person => {
        cleanGuestName(person);
      });
    }
    
    // Make cleanAllGuestNames available globally
    window.cleanAllGuestNames = cleanAllGuestNames;
    
    function updateTooltipsForPerson(person) {
      // Clean the guest name first
      cleanGuestName(person);
      
      // Find all seats that contain this person and update their tooltips
      const seats = document.querySelectorAll('#canvas .table.card .card-body .seat');
      seats.forEach(seat => {
        if (seat.children.length > 0 && seat.children[0] === person) {
          let guestName = person.querySelector('.guest-name')?.textContent || 'Unknown Guest';
          guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
          seat.setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
          seat.title = `${guestName} (Click to edit, drag to move)`;
        }
      });
    }
    
    /* ============================
       Guest/Seat Count Display
    ============================ */
    function updateCounts() {
      // Clean all guest names first to ensure consistency
      if (window.cleanAllGuestNames) {
        window.cleanAllGuestNames();
      }
      
      const allPersons = document.querySelectorAll('.person');
      const totalGuests = allPersons.length;
      let totalSeats = 0;
      document.querySelectorAll('#canvas .table.card').forEach(table => {
        totalSeats += parseInt(table.dataset.seatCount) || 0;
      });
      const countDiv = document.getElementById('guestSeatCounts');
      countDiv.innerHTML = `Total Guests: ${totalGuests} &nbsp;&nbsp; Total Seats: <span class="${totalGuests > totalSeats ? 'seat-count over' : 'seat-count'}">${totalSeats}</span>`;
      
      // Update assigned guests display
      updateAssignedGuestsDisplay();
    }
    
    /* ============================
       Assigned Guests Display
    ============================ */
    function updateAssignedGuestsDisplay() {
      const assignedContainer = document.getElementById('assigned-guests-list');
      
      // Store the current expanded state of tables
      const expandedTables = new Set();
      const existingTables = assignedContainer.querySelectorAll('.table-assignment');
      existingTables.forEach(tableDiv => {
        const tableName = tableDiv.dataset.tableName;
        const content = tableDiv.querySelector('.table-assignment-content');
        if (content && content.classList.contains('expanded')) {
          expandedTables.add(tableName);
        }
      });
      
      assignedContainer.innerHTML = '';
      
      const tables = document.querySelectorAll('#canvas .table.card');
      const tablesWithGuests = [];
      
      tables.forEach(table => {
        const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent || 'Unknown Table';
        const seats = table.querySelectorAll('.card-body .seat');
        const assignedGuests = [];
        
        seats.forEach((seat, index) => {
          if (seat.children.length > 0) {
            let guestName = seat.children[0].querySelector('.guest-name')?.textContent || 'Unknown Guest';
            // Clean the guest name by removing edit button characters
            guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
            assignedGuests.push({
              name: guestName,
              seatIndex: index + 1,
              personElement: seat.children[0],
              isAssigned: true
            });
          } else {
            // Add empty seat
            assignedGuests.push({
              name: 'Empty',
              seatIndex: index + 1,
              personElement: null,
              isAssigned: false
            });
          }
        });
        
        // Only add tables that have seats (all tables will have seats)
        tablesWithGuests.push({
          name: tableName,
          guests: assignedGuests
        });
      });
      
      if (tablesWithGuests.length === 0) {
        assignedContainer.innerHTML = '<p class="text-muted text-center">No tables created yet.</p>';
        return;
      }
      
      tablesWithGuests.forEach(tableData => {
        const tableDiv = document.createElement('div');
        tableDiv.className = 'table-assignment';
        tableDiv.draggable = true;
        tableDiv.dataset.tableName = tableData.name;
        
        const header = document.createElement('div');
        header.className = 'table-assignment-header';
        
        // Count assigned guests
        const assignedCount = tableData.guests.filter(guest => guest.isAssigned).length;
        const totalSeats = tableData.guests.length;
        
        header.innerHTML = `
          <div style="display: flex; align-items: center; gap: 8px;">
            <span class="drag-handle">â‹®â‹®</span>
            <span class="table-name">${tableData.name}</span>
          </div>
          <span class="guest-count">${assignedCount}/${totalSeats}</span>
        `;
        
        const content = document.createElement('div');
        content.className = 'table-assignment-content';
        
        tableData.guests.forEach(guest => {
          const guestItem = document.createElement('div');
          guestItem.className = 'guest-item';
          
          if (guest.isAssigned) {
            guestItem.innerHTML = `
              <div class="guest-info">
                <span class="drag-handle-guest" title="Drag to reorder">â‹®â‹®</span>
                <span class="guest-name">Seat ${guest.seatIndex}: ${guest.name}</span>
              </div>
              <div class="guest-controls">
                <button class="edit-guest-btn" title="Edit guest name">âœŽ</button>
                <button class="remove-guest-btn" title="Remove from table">âœ–</button>
              </div>
            `;
            
            // Make assigned guests draggable for reordering and moving to unassigned
            guestItem.draggable = true;
            guestItem.dataset.guestName = guest.name;
            guestItem.dataset.seatIndex = guest.seatIndex;
            guestItem.dataset.tableName = tableData.name;
            guestItem.dataset.personId = guest.personElement.id;
            
            guestItem.addEventListener('dragstart', handleGuestDragStart);
            guestItem.addEventListener('dragend', handleGuestDragEnd);
            guestItem.addEventListener('dragover', handleGuestDragOver);
            guestItem.addEventListener('dragenter', handleGuestDragEnter);
            guestItem.addEventListener('dragleave', handleGuestDragLeave);
            guestItem.addEventListener('drop', handleGuestDrop);
            
            // Add click handler to edit guest name
            const editBtn = guestItem.querySelector('.edit-guest-btn');
            editBtn.addEventListener('click', function(e) {
              e.stopPropagation(); // Prevent triggering the header click
              const newName = prompt("Edit guest name:", guest.name);
              if (newName && newName.trim() !== '') {
                // Update the guest name in the assigned guests list
                guest.name = newName.trim();
                
                // Find and update the actual guest element on the canvas
                const tables = document.querySelectorAll('#canvas .table.card');
                tables.forEach(table => {
                  const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
                  if (tableName === tableData.name) {
                    const seats = table.querySelectorAll('.card-body .seat');
                    if (seats[guest.seatIndex - 1] && seats[guest.seatIndex - 1].children.length > 0) {
                      const personElement = seats[guest.seatIndex - 1].children[0];
                      const nameSpan = personElement.querySelector('.guest-name');
                      if (nameSpan) {
                        nameSpan.textContent = newName.trim();
                        // Update tooltip for this seat
                        const seat = seats[guest.seatIndex - 1];
                        seat.setAttribute('data-tooltip', `${newName.trim()} (Click to edit, drag to move)`);
                        seat.title = `${newName.trim()} (Click to edit, drag to move)`;
                      }
                    }
                  }
                });
                
                // Update the display in the assigned guests list
                guestItem.querySelector('.guest-name').textContent = `Seat ${guest.seatIndex}: ${newName.trim()}`;
                
                // Update counts to refresh the display
                updateCounts();
              }
            });
            
            // Add click handler to remove guest from table
            const removeBtn = guestItem.querySelector('.remove-guest-btn');
            removeBtn.addEventListener('click', function(e) {
              e.stopPropagation(); // Prevent triggering the header click
              if (confirm(`Remove ${guest.name} from ${tableData.name}?`)) {
                // Find the actual seat and remove the guest
                const tables = document.querySelectorAll('#canvas .table.card');
                tables.forEach(table => {
                  const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
                  if (tableName === tableData.name) {
                    const seats = table.querySelectorAll('.card-body .seat');
                    if (seats[guest.seatIndex - 1] && seats[guest.seatIndex - 1].children.length > 0) {
                      const person = seats[guest.seatIndex - 1].children[0];
                      document.getElementById('people-list').appendChild(person);
                      seats[guest.seatIndex - 1].innerHTML = '';
                      seats[guest.seatIndex - 1].classList.remove('filled');
                      // Clear tooltip and title from the seat
                      seats[guest.seatIndex - 1].removeAttribute('data-tooltip');
                      seats[guest.seatIndex - 1].removeAttribute('title');
                      updateCounts();
                    }
                  }
                });
              }
            });
          } else {
            // Empty seat
            guestItem.innerHTML = `
              <span class="guest-name empty-seat">Seat ${guest.seatIndex}: Empty</span>
              <span class="drop-hint">Drop guest here or click to assign</span>
            `;
            guestItem.classList.add('empty-seat-item');
            guestItem.style.cursor = 'pointer';
            guestItem.title = 'Drop a guest here or click to assign them to this seat';
            
            // Add click handler to open assignment modal
            guestItem.addEventListener('click', function(e) {
              // Don't open modal if clicking on drop hint or if this is a drag operation
              if (e.target.classList.contains('drop-hint') || draggedGuest) {
                return;
              }
              
              // Find the actual seat on the canvas and open the assignment modal
              const tables = document.querySelectorAll('#canvas .table.card');
              tables.forEach(table => {
                const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
                if (tableName === tableData.name) {
                  const seats = table.querySelectorAll('.card-body .seat');
                  if (seats[guest.seatIndex - 1]) {
                    openAssignmentModal(seats[guest.seatIndex - 1]);
                  }
                }
              });
            });
            
            // Make empty seats droppable
            guestItem.addEventListener('dragover', function(e) {
              e.preventDefault();
              e.stopPropagation();
              if (isDragging && draggedElement) {
                this.classList.add('over');
              }
            });
            guestItem.addEventListener('dragleave', function(e) {
              e.stopPropagation();
              this.classList.remove('over');
            });
            guestItem.addEventListener('drop', function(e) {
              e.preventDefault();
              e.stopPropagation();
              this.classList.remove('over');
              
              const personId = e.dataTransfer.getData('text/plain');
              const personElem = document.getElementById(personId);
              
              if (personElem && isDragging) {
                // Find the actual seat on the canvas and assign the guest
                const tables = document.querySelectorAll('#canvas .table.card');
                tables.forEach(table => {
                  const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
                  if (tableName === tableData.name) {
                    const seats = table.querySelectorAll('.card-body .seat');
                    const targetSeat = seats[guest.seatIndex - 1];
                    if (targetSeat && !targetSeat.classList.contains('filled')) {
                      const sourceParent = personElem.parentElement;

                      // Remove from source if it was in a seat
                      if (sourceParent && sourceParent.classList.contains('seat')) {
                        sourceParent.classList.remove('filled');
                        sourceParent.removeAttribute('data-tooltip');
                        sourceParent.removeAttribute('title');
                      }

                      // Add guest to the new seat
                      targetSeat.innerHTML = '';
                      targetSeat.appendChild(personElem);
                      targetSeat.classList.add('filled');
                      
                      // Add tooltip to the seat element
                      let guestName = personElem.querySelector('.guest-name')?.textContent || 'Unknown Guest';
                      guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
                      targetSeat.setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
                      targetSeat.title = `${guestName} (Click to edit, drag to move)`;
                      
                              // Ensure the person element remains draggable
        personElem.draggable = true;
        personElem.addEventListener('dragstart', window.dragDropModule.handleDragStart);
        personElem.addEventListener('dragend', window.dragDropModule.handlePersonDragEnd);
                      
                      // Update the display
                      updateCounts();
                    }
                  }
                });
              }
            });
          }
          
          content.appendChild(guestItem);
        });
        
        // Add click handler to expand/collapse table
        header.addEventListener('click', function(e) {
          // Don't expand/collapse if clicking on control buttons
          if (e.target.classList.contains('remove-guest-btn') || 
              e.target.classList.contains('edit-guest-btn') ||
              e.target.closest('.guest-controls')) {
            return;
          }
          content.classList.toggle('expanded');
        });
        
        // Add drag and drop functionality
        tableDiv.addEventListener('dragstart', handleTableDragStart);
        tableDiv.addEventListener('dragend', handleTableDragEnd);
        tableDiv.addEventListener('dragover', handleTableDragOver);
        tableDiv.addEventListener('dragenter', handleTableDragEnter);
        tableDiv.addEventListener('dragleave', handleTableDragLeave);
        tableDiv.addEventListener('drop', handleTableDrop);
        
        tableDiv.appendChild(header);
        tableDiv.appendChild(content);
        assignedContainer.appendChild(tableDiv);
        
        // Restore expanded state if this table was previously expanded
        if (expandedTables.has(tableData.name)) {
          content.classList.add('expanded');
        }
      });
    }
    
    /* ============================
       Table Reordering Drag & Drop
    ============================ */
    let draggedTable = null;
    
    function handleTableDragStart(e) {
      // Don't start table drag if dragging a guest
      if (draggedGuest) {
        return;
      }
      draggedTable = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.outerHTML);
    }
    
    function handleTableDragEnd(e) {
      // Don't end table drag if dragging a guest
      if (draggedGuest) {
        return;
      }
      this.classList.remove('dragging');
      draggedTable = null;
    }
    
    function handleTableDragOver(e) {
      // Don't handle table drag over if dragging a guest
      if (draggedGuest) {
        return;
      }
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }
    
    function handleTableDragEnter(e) {
      // Don't handle table drag enter if dragging a guest
      if (draggedGuest) {
        return;
      }
      e.preventDefault();
      if (this !== draggedTable) {
        this.classList.add('drag-over');
      }
    }
    
    function handleTableDragLeave(e) {
      // Don't handle table drag leave if dragging a guest
      if (draggedGuest) {
        return;
      }
      this.classList.remove('drag-over');
    }
    
    function handleTableDrop(e) {
      // Don't handle table drop if dragging a guest
      if (draggedGuest) {
        return;
      }
      e.preventDefault();
      this.classList.remove('drag-over');
      
      if (draggedTable && this !== draggedTable) {
        const container = document.getElementById('assigned-guests-list');
        const allTables = Array.from(container.querySelectorAll('.table-assignment'));
        const draggedIndex = allTables.indexOf(draggedTable);
        const dropIndex = allTables.indexOf(this);
        
        if (draggedIndex < dropIndex) {
          // Moving down
          this.parentNode.insertBefore(draggedTable, this.nextSibling);
        } else {
          // Moving up
          this.parentNode.insertBefore(draggedTable, this);
        }
      }
    }
    
    /* ============================
       Guest Reordering Drag & Drop
    ============================ */
    let draggedGuest = null;
    
    function handleGuestDragStart(e) {
      e.stopPropagation(); // Prevent table drag from starting
      draggedGuest = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', this.dataset.personId);
    }
    
    function handleGuestDragEnd(e) {
      e.stopPropagation(); // Prevent table drag from ending
      this.classList.remove('dragging');
      draggedGuest = null;
    }
    
    function handleGuestDragOver(e) {
      e.preventDefault();
      e.stopPropagation(); // Prevent table drag over
      e.dataTransfer.dropEffect = 'move';
    }
    
    function handleGuestDragEnter(e) {
      e.preventDefault();
      e.stopPropagation(); // Prevent table drag enter
      if (this !== draggedGuest && this.dataset.tableName === draggedGuest?.dataset.tableName) {
        this.classList.add('drag-over');
      }
    }
    
    function handleGuestDragLeave(e) {
      e.stopPropagation(); // Prevent table drag leave
      this.classList.remove('drag-over');
    }
    
    function handleGuestDrop(e) {
      e.preventDefault();
      e.stopPropagation(); // Prevent table drop
      this.classList.remove('drag-over');
      
      if (draggedGuest && this !== draggedGuest && this.dataset.tableName === draggedGuest.dataset.tableName) {
        // Get the table content container
        const tableContent = this.closest('.table-assignment-content');
        const allGuests = Array.from(tableContent.querySelectorAll('.guest-item:not(.empty-seat-item)'));
        const draggedIndex = allGuests.indexOf(draggedGuest);
        const dropIndex = allGuests.indexOf(this);
        
        if (draggedIndex !== -1 && dropIndex !== -1) {
          // Reorder in the assigned guests list
          if (draggedIndex < dropIndex) {
            // Moving down
            this.parentNode.insertBefore(draggedGuest, this.nextSibling);
          } else {
            // Moving up
            this.parentNode.insertBefore(draggedGuest, this);
          }
          
          // Update the canvas to reflect the new order
          updateCanvasFromAssignedGuestsOrder(tableContent);
        }
      }
    }
    
    function updateCanvasFromAssignedGuestsOrder(tableContent) {
      const tableName = tableContent.closest('.table-assignment').dataset.tableName;
      const guestItems = tableContent.querySelectorAll('.guest-item:not(.empty-seat-item)');
      
      // Find the corresponding table on the canvas
      const tables = document.querySelectorAll('#canvas .table.card');
      tables.forEach(table => {
        const canvasTableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
        if (canvasTableName === tableName) {
          const seats = table.querySelectorAll('.card-body .seat');
          
          // Clear all seats first
          seats.forEach(seat => {
            if (seat.children.length > 0) {
              const person = seat.children[0];
              document.getElementById('people-list').appendChild(person);
              seat.innerHTML = '';
              seat.classList.remove('filled');
              // Clear tooltip and title from the seat
              seat.removeAttribute('data-tooltip');
              seat.removeAttribute('title');
            }
          });
          
          // Reassign guests in the new order
          guestItems.forEach((guestItem, index) => {
            const guestName = guestItem.dataset.guestName;
            
            // Find the person element in the unassigned list by name
            const unassignedPersons = document.querySelectorAll('#people-list .person');
            let personElement = null;
            
            for (let person of unassignedPersons) {
              const nameSpan = person.querySelector('.guest-name');
              if (nameSpan) {
                // Clean the name for comparison (remove edit buttons)
                const cleanName = nameSpan.textContent.replace(/[âœŽâœ–]/g, '').trim();
                if (cleanName === guestName) {
                  personElement = person;
                  break;
                }
              }
            }
            
            if (personElement) {
              // Remove from unassigned list
              personElement.remove();
              
              // Add to the seat
              seats[index].innerHTML = '';
              seats[index].appendChild(personElement);
              seats[index].classList.add('filled');
              
              // Ensure the person element remains draggable
              personElement.draggable = true;
              personElement.addEventListener('dragstart', handleDragStart);
              personElement.addEventListener('dragend', handlePersonDragEnd);
              
              // Add tooltip to the seat element
              let guestName = personElement.querySelector('.guest-name')?.textContent || 'Unknown Guest';
              guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
              seats[index].setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
              seats[index].title = `${guestName} (Click to edit, drag to move)`;
            }
          });
          
          // Update seat numbers in the assigned guests list
          guestItems.forEach((guestItem, index) => {
            const guestNameSpan = guestItem.querySelector('.guest-name');
            if (guestNameSpan) {
              const currentText = guestNameSpan.textContent;
              const guestName = currentText.replace(/^Seat \d+: /, '');
              guestNameSpan.textContent = `Seat ${index + 1}: ${guestName}`;
              guestItem.dataset.seatIndex = index + 1;
            }
          });
          
          // Update counts
          updateCounts();
        }
      });
    }
    
    /* ============================
       Form to Add a New Guest
    ============================ */
    document.getElementById('addGuestForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const newName = document.getElementById('newGuestName').value.trim();
      if (newName) {
        addPerson(newName);
        document.getElementById('newGuestName').value = '';
      }
    });
    
    /* ============================
       Table Handling with Variable Seat Count
    ============================ */
    let tableCounter = 0;
    function createTableContainer(tableId, tableName, tableBodyElem, width, height, tableType, seatCount, leftPos, topPos) {
      console.log('Creating table container:', { tableId, tableName, tableType, seatCount });
      
      const tableContainer = document.createElement('div');
      tableContainer.className = 'table card' + (tableType === "circle" ? " circle" : "");
      tableContainer.id = tableId;
      tableContainer.style.position = 'absolute';
      if (leftPos !== undefined && topPos !== undefined) {
        tableContainer.style.left = leftPos;
        tableContainer.style.top = topPos;
      } else {
        tableContainer.style.left = (50 + (tableCounter * 20)) + 'px';
        tableContainer.style.top = (50 + (tableCounter * 20)) + 'px';
      }
      tableContainer.style.width = (width + 20) + 'px';
      tableContainer.dataset.tableType = tableType;
      tableContainer.dataset.width = width;
      tableContainer.dataset.height = height;
      tableContainer.dataset.seatCount = seatCount;
      
      const header = document.createElement('div');
      header.className = 'card-header table-header d-flex';
      if (tableType === "circle") {
        const nameDiv = document.createElement('div');
        nameDiv.className = 'table-name';
        nameDiv.textContent = tableName;
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'header-controls mt-1';
        const renameBtn = document.createElement('button');
        renameBtn.className = 'btn btn-sm btn-secondary';
        renameBtn.textContent = 'Rename';
        renameBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const newName = prompt('Enter new table name:', nameDiv.textContent);
          if (newName) { nameDiv.textContent = newName; }
        });
        controlsDiv.appendChild(renameBtn);
        const editSeatsBtn = document.createElement('button');
        editSeatsBtn.className = 'btn btn-sm btn-info';
        editSeatsBtn.textContent = 'Edit Seats';
        editSeatsBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const currentCount = parseInt(tableContainer.dataset.seatCount);
          const newCount = parseInt(prompt('Enter new number of seats (minimum 1):', currentCount));
          if (isNaN(newCount) || newCount < 1) return;
          updateTableSeats(tableContainer, newCount);
        });
        controlsDiv.appendChild(editSeatsBtn);
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-sm btn-danger';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (confirm('Are you sure you want to remove this table?')) {
            const seats = tableContainer.querySelectorAll('.seat');
            seats.forEach(seat => {
              if (seat.children.length > 0) {
                document.getElementById('people-list').appendChild(seat.children[0]);
              }
            });
            tableContainer.remove();
            updateCounts();
          }
        });
        controlsDiv.appendChild(removeBtn);
        header.appendChild(nameDiv);
        header.appendChild(controlsDiv);
      } else {
        console.log('Creating rectangle table header with name:', tableName);
        const titleSpan = document.createElement('span');
        titleSpan.className = 'table-title';
        titleSpan.textContent = tableName;
        header.appendChild(titleSpan);
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'header-controls ms-auto';
        const renameBtn = document.createElement('button');
        renameBtn.className = 'btn btn-sm btn-secondary';
        renameBtn.textContent = 'Rename';
        renameBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const newName = prompt('Enter new table name:', titleSpan.textContent);
          if (newName) { titleSpan.textContent = newName; }
        });
        controlsDiv.appendChild(renameBtn);
        const editSeatsBtn = document.createElement('button');
        editSeatsBtn.className = 'btn btn-sm btn-info ms-1';
        editSeatsBtn.textContent = 'Edit Seats';
        editSeatsBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const currentCount = parseInt(tableContainer.dataset.seatCount);
          const newCount = parseInt(prompt('Enter new number of seats (minimum 1):', currentCount));
          if (isNaN(newCount) || newCount < 1) return;
          updateTableSeats(tableContainer, newCount);
        });
        controlsDiv.appendChild(editSeatsBtn);
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-sm btn-danger ms-1';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (confirm('Are you sure you want to remove this table?')) {
            const seats = tableContainer.querySelectorAll('.seat');
            seats.forEach(seat => {
              if (seat.children.length > 0) {
                document.getElementById('people-list').appendChild(seat.children[0]);
              }
            });
            tableContainer.remove();
            updateCounts();
          }
        });
        controlsDiv.appendChild(removeBtn);
        header.appendChild(controlsDiv);
      }
      
      tableContainer.appendChild(header);
      tableContainer.appendChild(tableBodyElem);
      document.getElementById('canvas').appendChild(tableContainer);
      makeTableDraggable(tableContainer);
      tableCounter++;
      updateCounts();
    }
    
    function createCircleTable(tableId, tableName, seatCount, imported = false, leftPos, topPos) {
      const width = 200, height = 200;
      const tableBody = document.createElement('div');
      tableBody.className = 'card-body table-body';
      tableBody.style.position = 'relative';
      tableBody.style.width = width + 'px';
      tableBody.style.height = height + 'px';
      tableBody.style.border = '2px solid #333';
      tableBody.style.borderRadius = '50%';
      tableBody.style.margin = '0px';
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = width / 2 - 20; // keep seats inside border

      for (let i = 0; i < seatCount; i++) {
        const angle = (2 * Math.PI / seatCount) * i;
        const seat = document.createElement('div');
        seat.className = 'seat';
        seat.style.left = (centerX + radius * Math.cos(angle) - 20) + 'px';
        seat.style.top = (centerY + radius * Math.sin(angle) - 20) + 'px';
        seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
        seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
        seat.addEventListener('drop', window.dragDropModule.handleDrop);
        seat.addEventListener('click', function(e) {
          e.stopPropagation();
          openAssignmentModal(seat);
        });
        tableBody.appendChild(seat);
      }
      createTableContainer(tableId, tableName, tableBody, width, height, "circle", seatCount, leftPos, topPos);
    }
    
    function createRectangleTable(tableId, tableName, seatCount, imported = false, leftPos, topPos) {
      const width = 300, height = 150;
      const tableBody = document.createElement('div');
      tableBody.className = 'card-body table-body';
      tableBody.style.position = 'relative';
      tableBody.style.width = width + 'px';
      tableBody.style.height = height + 'px';
      tableBody.style.border = '2px solid #333';
      tableBody.style.borderRadius = '5px';
      tableBody.style.margin = '0px';
      tableBody.style.boxSizing = 'border-box';
      
      // For rectangle tables, distribute seats evenly around the perimeter
      // Use a simple approach: calculate positions based on perimeter distance
      const perimeter = 2 * (width + height);
      const seatSpacing = perimeter / seatCount;
      
      // Create exactly the requested number of seats
      for (let i = 0; i < seatCount; i++) {
        const seat = document.createElement('div');
        seat.className = 'seat';
        
        // Calculate position along the perimeter
        const distance = i * seatSpacing;
        let x, y;
        
        if (distance < width) {
          // Top edge
          x = distance;
          y = 0;
        } else if (distance < width + height) {
          // Right edge
          x = width;
          y = distance - width;
        } else if (distance < 2 * width + height) {
          // Bottom edge
          x = width - (distance - (width + height));
          y = height;
        } else {
          // Left edge
          x = 0;
          y = height - (distance - (2 * width + height));
        }
        
        seat.style.left = (x - 20) + 'px';
        seat.style.top = (y - 20) + 'px';
        
        seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
        seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
        seat.addEventListener('drop', window.dragDropModule.handleDrop);
        seat.addEventListener('click', function(e) {
          e.stopPropagation();
          openAssignmentModal(seat);
        });
        tableBody.appendChild(seat);
      }
      
      createTableContainer(tableId, tableName, tableBody, width, height, "rectangle", seatCount, leftPos, topPos);
    }
    
    function makeTableDraggable(tableElem) {
      const header = tableElem.querySelector('.table-header');
      header.style.cursor = 'move';
      header.addEventListener('mousedown', function(e) {
        if (e.button !== 0) return;
        let offsetX = e.clientX - tableElem.offsetLeft;
        let offsetY = e.clientY - tableElem.offsetTop;
        function mouseMoveHandler(e) {
          tableElem.style.left = (e.clientX - offsetX) + 'px';
          tableElem.style.top = (e.clientY - offsetY) + 'px';
        }
        function mouseUpHandler(e) {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
        }
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler);
      });
    }
    
    function updateTableSeats(tableContainer, newSeatCount) {
      const tableType = tableContainer.dataset.tableType;
      const width = parseInt(tableContainer.dataset.width);
      const height = parseInt(tableContainer.dataset.height);
      const oldAssigned = [];
      const oldSeats = tableContainer.querySelectorAll('.card-body .seat');
      oldSeats.forEach(seat => {
        if (seat.children.length > 0) {
          oldAssigned.push(seat.children[0]);
        }
      });
      const oldBody = tableContainer.querySelector('.card-body');
      oldBody.remove();
      let newBody;
      if (tableType === "circle") {
        newBody = document.createElement('div');
        newBody.className = 'card-body table-body';
        newBody.style.position = 'relative';
        newBody.style.width = width + 'px';
        newBody.style.height = height + 'px';
        newBody.style.border = '2px solid #333';
        newBody.style.borderRadius = '50%';
        newBody.style.margin = '0px';
        newBody.style.boxSizing = 'border-box';
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = width / 2 - 20;
        for (let i = 0; i < newSeatCount; i++) {
          const angle = (2 * Math.PI / newSeatCount) * i;
          const seat = document.createElement('div');
          seat.className = 'seat';
          seat.style.left = (centerX + radius * Math.cos(angle) - 20) + 'px';
          seat.style.top  = (centerY + radius * Math.sin(angle) - 20) + 'px';
          seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
          seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
          seat.addEventListener('drop', window.dragDropModule.handleDrop);
          seat.addEventListener('click', function(e) {
            e.stopPropagation();
            openAssignmentModal(seat);
          });
          newBody.appendChild(seat);
        }
      } else if (tableType === "rectangle") {
        newBody = document.createElement('div');
        newBody.className = 'card-body table-body';
        newBody.style.position = 'relative';
        newBody.style.width = width + 'px';
        newBody.style.height = height + 'px';
        newBody.style.border = '2px solid #333';
        newBody.style.borderRadius = '5px';
        newBody.style.margin = '0px';
        newBody.style.boxSizing = 'border-box';
        
        // For rectangle tables, distribute seats evenly around the perimeter
        // Use a simple approach: calculate positions based on perimeter distance
        const perimeter = 2 * (width + height);
        const seatSpacing = perimeter / newSeatCount;
        
        // Create exactly the requested number of seats
        for (let i = 0; i < newSeatCount; i++) {
          const seat = document.createElement('div');
          seat.className = 'seat';
          
          // Calculate position along the perimeter
          const distance = i * seatSpacing;
          let x, y;
          
          if (distance < width) {
            // Top edge
            x = distance;
            y = 0;
          } else if (distance < width + height) {
            // Right edge
            x = width;
            y = distance - width;
          } else if (distance < 2 * width + height) {
            // Bottom edge
            x = width - (distance - (width + height));
            y = height;
          } else {
            // Left edge
            x = 0;
            y = height - (distance - (2 * width + height));
          }
          
          seat.style.left = (x - 20) + 'px';
          seat.style.top  = (y - 20) + 'px';
          
          seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
          seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
          seat.addEventListener('drop', window.dragDropModule.handleDrop);
          seat.addEventListener('click', function(e) {
            e.stopPropagation();
            openAssignmentModal(seat);
          });
          newBody.appendChild(seat);
        }
      }
      const newSeats = newBody.children;
      const assignCount = Math.min(oldAssigned.length, newSeatCount);
      for (let i = 0; i < assignCount; i++) {
         newSeats[i].innerHTML = '';
         newSeats[i].appendChild(oldAssigned[i]);
         newSeats[i].classList.add('filled');
      }
      for (let i = assignCount; i < oldAssigned.length; i++) {
         document.getElementById('people-list').appendChild(oldAssigned[i]);
      }
      tableContainer.appendChild(newBody);
      tableContainer.dataset.seatCount = newSeatCount;
    }
    
    /* ============================
       Assignment Modal Handling
    ============================ */
    let currentSeat = null;
    function openAssignmentModal(seat) {
      currentSeat = seat;
      document.getElementById('clearSeatBtn').style.display = seat.children.length > 0 ? 'inline-block' : 'none';
      document.getElementById('assignmentSearch').value = '';
      refreshAssignmentModalList();
      const modalEl = document.getElementById('assignmentModal');
      const modal = new bootstrap.Modal(modalEl);
      modal.show();
    }
    function refreshAssignmentModalList() {
      const searchQuery = document.getElementById('assignmentSearch').value.toLowerCase();
      const assignmentList = document.getElementById('assignmentList');
      assignmentList.innerHTML = '';
      const availablePersons = Array.from(document.querySelectorAll("#people-list .person"));
      availablePersons.forEach(person => {
        if (person.textContent.toLowerCase().includes(searchQuery)) {
          const li = document.createElement('li');
          li.className = 'list-group-item list-group-item-action';
          
          // Create a clean version without edit buttons for the modal
          const nameSpan = person.querySelector('.guest-name');
          const guestName = nameSpan ? nameSpan.textContent.replace(/[âœŽâœ–]/g, '').trim() : 'Unknown Guest';
          
          li.innerHTML = `
            <span class="person-icon">ðŸ‘¤</span>
            <span class="guest-name">${guestName}</span>
          `;
          
          li.addEventListener('click', function(e) {
            // Don't trigger if clicking on edit buttons
            if (e.target.classList.contains('edit-guest-btn') || e.target.classList.contains('remove-guest-btn')) {
              return;
            }
            assignPersonToSeat(person, currentSeat);
          });
          assignmentList.appendChild(li);
        }
      });
    }
    function assignPersonToSeat(person, seat) {
      // Clean the guest name first
      cleanGuestName(person);
      
      if (seat.children.length > 0) {
        const existing = seat.children[0];
        document.getElementById('people-list').appendChild(existing);
      }
      const source = person.parentElement;
      if (source && source.classList.contains('seat')) {
        source.classList.remove('filled');
      }
      seat.innerHTML = '';
      seat.appendChild(person);
      seat.classList.add('filled');
      
      // Ensure the person element remains draggable
      person.draggable = true;
      person.addEventListener('dragstart', handleDragStart);
      person.addEventListener('dragend', handlePersonDragEnd);
      
      // Add tooltip to the seat element
      let guestName = person.querySelector('.guest-name')?.textContent || 'Unknown Guest';
      guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
      seat.setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
      seat.title = `${guestName} (Click to edit, drag to move)`;
      
      const modalEl = document.getElementById('assignmentModal');
      const modal = bootstrap.Modal.getInstance(modalEl);
      modal.hide();
      updateCounts();
    }
    function clearSeatAssignment() {
      if (currentSeat && currentSeat.children.length > 0) {
        const person = currentSeat.children[0];
        document.getElementById('people-list').appendChild(person);
        currentSeat.innerHTML = '';
        currentSeat.classList.remove('filled');
        // Clear tooltip and title from the seat
        currentSeat.removeAttribute('data-tooltip');
        currentSeat.removeAttribute('title');
      }
      const modalEl = document.getElementById('assignmentModal');
      const modal = bootstrap.Modal.getInstance(modalEl);
      modal.hide();
      updateCounts();
    }
    document.getElementById('assignmentSearch').addEventListener('input', refreshAssignmentModalList);
    document.getElementById('clearSeatBtn').addEventListener('click', clearSeatAssignment);
    
    /* ============================
       Random Assignment
    ============================ */
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
         const j = Math.floor(Math.random() * (i + 1));
         [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    function randomAssign() {
      let unassignedPeople = Array.from(document.querySelectorAll("#people-list .person"));
      unassignedPeople = shuffleArray(unassignedPeople);
      // Only select seats that are actually part of tables, not orphaned seats
      let emptySeats = Array.from(document.querySelectorAll("#canvas .table.card .card-body .seat")).filter(seat => seat.children.length === 0);
      emptySeats = shuffleArray(emptySeats);
      const assignCount = Math.min(unassignedPeople.length, emptySeats.length);
      for (let i = 0; i < assignCount; i++) {
        const seat = emptySeats[i];
        const person = unassignedPeople[i];
        seat.appendChild(person);
        seat.classList.add('filled');
        
        // Add tooltip to the seat element
        let guestName = person.querySelector('.guest-name')?.textContent || 'Unknown Guest';
        guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
        seat.setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
        seat.title = `${guestName} (Click to edit, drag to move)`;
      }
      updateCounts();
    }
    document.getElementById('randomAssignBtn').addEventListener('click', randomAssign);
    
    /* ============================
       Export / Import State as JSON
    ============================ */
    function getState() {
      const state = { tables: [], unassigned: [] };
      const tableElements = document.querySelectorAll("#canvas .table.card");
      tableElements.forEach(table => {
         const tableName = table.querySelector(".table-title")?.textContent || table.querySelector(".table-name").textContent;
         const tableType = table.dataset.tableType || "";
         const left = table.style.left;
         const top = table.style.top;
         const width = table.dataset.width;
         const height = table.dataset.height;
         const seatCount = table.dataset.seatCount;
         const seats = [];
         const seatElements = table.querySelectorAll(".card-body .seat");
         seatElements.forEach((seat, index) => {
            let guest = "";
            if (seat.children.length > 0) {
                guest = seat.children[0].textContent.replace("ðŸ‘¤", "").trim();
            }
            seats.push({ seatIndex: index + 1, guest: guest });
         });
         state.tables.push({ tableName, tableType, left, top, width, height, seatCount, seats });
      });
      const unassignedElements = document.querySelectorAll("#people-list .person");
unassignedElements.forEach(person => {
   const guest = person.querySelector('.guest-name').textContent.trim();
   state.unassigned.push(guest);
});

      return state;
    }
    function exportState() {
      const state = getState();
      const jsonString = JSON.stringify(state, null, 2);
      const blob = new Blob([jsonString], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "table_state.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
    document.getElementById('exportStateBtn').addEventListener('click', exportState);
    function importState(jsonText) {
      const state = JSON.parse(jsonText);
      document.getElementById('canvas').innerHTML = "";
      document.getElementById('people-list').innerHTML = "";
      state.tables.forEach(table => {
         const tableId = 'table-' + Date.now() + '-' + Math.random().toString(36).substr(2,5);
         const seatCount = parseInt(table.seatCount);
         if (table.tableType === "circle") {
            createCircleTable(tableId, table.tableName, seatCount, true, table.left, table.top);
         } else {
            createRectangleTable(tableId, table.tableName, seatCount, true, table.left, table.top);
         }
         const tableContainer = document.getElementById('canvas').lastElementChild;
         const seats = tableContainer.querySelectorAll(".card-body .seat");
         table.seats.forEach(seatData => {
            const idx = seatData.seatIndex - 1;
            if (idx >= 0 && idx < seats.length && seatData.guest) {
               seats[idx].innerHTML = '';
               const personElement = createPersonElement(seatData.guest);
               seats[idx].appendChild(personElement);
               seats[idx].classList.add('filled');
               
                     // Add tooltip to the seat element
      let guestName = personElement.querySelector('.guest-name')?.textContent || 'Unknown Guest';
      guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
      seats[idx].setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
      seats[idx].title = `${guestName} (Click to edit, drag to move)`;
            }
         });
      });
      state.unassigned.forEach(guest => {
         addPerson(guest);
      });
      updateCounts();
    }
    document.getElementById('importStateBtn').addEventListener('click', function() {
      document.getElementById('importStateFile').click();
    });
    document.getElementById('importStateFile').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
         importState(e.target.result);
      }
      reader.readAsText(file);
    });
    
    /* ============================
       Human-Readable Print Option
    ============================ */
    function printPlan() {
      let html = '<html><head><title>Wedding Seating Plan</title>';
      html += '<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">';
      html += '<style>body{padding:20px; font-family: Roboto, sans-serif;} h1, h2 {margin-top:20px;} ul {list-style: none; padding: 0;} li {margin-bottom: 5px;}</style></head><body>';
      html += '<h1>Wedding Seating Plan</h1>';
      
      // Get tables in the order they appear in the assigned guests panel
      const assignedContainer = document.getElementById('assigned-guests-list');
      const tableDivs = assignedContainer.querySelectorAll('.table-assignment');
      
      tableDivs.forEach(tableDiv => {
        const tableName = tableDiv.dataset.tableName;
        const guestItems = tableDiv.querySelectorAll('.guest-item');
        
        if (guestItems.length > 0) {
          html += `<h2>${tableName}</h2>`;
          html += `<p>Seats: ${guestItems.length}</p>`;
  html += '<ul>';
          
          guestItems.forEach(guestItem => {
            const guestNameElement = guestItem.querySelector('.guest-name');
            if (guestNameElement) {
              // Extract only the guest name, excluding any edit buttons
              let guestName = guestNameElement.textContent;
              // Remove any edit button text (âœŽ or âœ–) and clean up
              guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
              html += `<li>${guestName}</li>`;
            }
          });
          
  html += '</ul>';
        }
      });
      
      // Get unassigned guests
      const unassignedGuests = [];
      const unassignedElements = document.querySelectorAll('#people-list .person');
      unassignedElements.forEach(person => {
        const guestName = person.querySelector('.guest-name')?.textContent || 'Unknown Guest';
        unassignedGuests.push(guestName);
      });
      
      if (unassignedGuests.length > 0) {
         html += '<h2>Unassigned Guests</h2>';
         html += '<ul>';
         unassignedGuests.forEach(guest => {
            html += `<li>${guest}</li>`;
         });
         html += '</ul>';
      }
      html += '</body></html>';
      const printWindow = window.open('', '', 'width=800,height=600');
      printWindow.document.write(html);
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
    }
    document.getElementById('printPlanBtn').addEventListener('click', printPlan);
    
    /* ============================
       New Table Modal Form Handling
    ============================ */
    document.getElementById('newTableForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const tableName = document.getElementById('tableName').value.trim();
      const tableType = document.getElementById('tableType').value;
      const seatCount = parseInt(document.getElementById('seatCount').value);
      
      console.log('Creating table:', { tableName, tableType, seatCount });
      
      if (!tableName || isNaN(seatCount) || seatCount < 1) {
        console.log('Validation failed:', { tableName, seatCount });
        return;
      }
      
      const tableId = 'table-' + Date.now();
      if (tableType === 'circle') {
        createCircleTable(tableId, tableName, seatCount);
      } else {
        createRectangleTable(tableId, tableName, seatCount);
      }
      const modalEl = document.getElementById('newTableModal');
      const modal = bootstrap.Modal.getInstance(modalEl);
      modal.hide();
      this.reset();
      
      // Clean up any orphaned seats after table creation
      setTimeout(cleanupOrphanedSeats, 100);
    });
    
    /* ============================
       Cleanup orphaned seats
    ============================ */
    function cleanupOrphanedSeats() {
      // Remove any seats that are not inside table card bodies
      const allSeats = document.querySelectorAll('.seat');
      allSeats.forEach(seat => {
        if (!seat.closest('#canvas .table.card .card-body')) {
          seat.remove();
        }
      });
      
      // Also remove any seats that are direct children of the canvas
      const canvas = document.getElementById('canvas');
      const directSeats = canvas.querySelectorAll(':scope > .seat');
      directSeats.forEach(seat => {
        seat.remove();
      });
    }
    
    /* ============================
       No default tables on load.
    ============================ */
    
    /* ============================
       Initialize the page
    ============================ */
    // Initialize the assigned guests display on page load
    updateAssignedGuestsDisplay();
    
    // Clean up any orphaned seats on page load
    cleanupOrphanedSeats();
    
  </script>
</body>
</html>
