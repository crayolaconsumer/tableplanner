<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Wedding Table Plan Creator</title>
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  
  <!-- Firebase Config -->
  <script src="firebase-config.js"></script>

</head>
<body>
  <div class="container-fluid">
    <!-- Top Controls (camera controls now use intuitive mouse actions) -->
    <div id="controls" class="no-print">
      <div class="row align-items-end">
        <div class="col-md-4">
          <label for="csv-file" class="form-label">Import Guest CSV (first column = name)</label>
          <input type="file" id="csv-file" accept=".csv" class="form-control">
        </div>
        <div class="col-md-8 text-end">
          <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newTableModal">
            New Table
          </button>
          <button type="button" class="btn btn-secondary ms-2" id="randomAssignBtn">Random Assign</button>
          <button type="button" class="btn btn-success ms-2" id="exportStateBtn">Export Plan</button>
          <button type="button" class="btn btn-info ms-2" id="importStateBtn">Import Plan</button>
          <button type="button" class="btn btn-warning ms-2" id="printPlanBtn">Print Plan</button>
          <button type="button" class="btn btn-primary ms-2" id="collaborateBtn" title="Enable real-time collaboration">
            <span id="collaborateIcon">ðŸ”—</span> <span id="collaborateText">Start Collaboration</span>
          </button>
          <button type="button" class="btn btn-outline-secondary ms-2" id="download-template-btn" title="Download CSV template">
            ðŸ“¥ Template
          </button>
          <!-- Hidden file input for JSON state import -->
          <input type="file" id="importStateFile" accept=".json" style="display:none;">
        </div>
      </div>
      <p class="text-muted mt-2 desktop-instructions">Use your mouse wheel to zoom. Click and drag on any blank area (i.e. not on a table) to pan the canvas.</p>
      <div class="mobile-instructions" style="display: none;">
        <strong>ðŸ“± Mobile Controls:</strong> Pinch to zoom â€¢ Drag to pan â€¢ Double-tap to reset â€¢ Swipe from edges or tap buttons to open menus
    </div>
    </div>
    <div class="row" id="main-layout">
        <!-- Left: Unassigned People Panel -->
        <div class="sidebar" id="unassigned-sidebar" data-title="Unassigned Guests">
        <div id="people-container">
            <div class="sidebar-header">
              <h5>Unassigned Guests</h5>
              <button class="btn btn-sm btn-outline-secondary sidebar-toggle" id="unassigned-toggle" title="Collapse sidebar">
                <span class="toggle-icon">â—€</span>
              </button>
            </div>
          <!-- Guest/Seat counts -->
          <div id="guestSeatCounts"></div>
          <!-- Button to add a new guest -->
          <div class="mb-3">
            <button type="button" class="btn btn-outline-primary w-100" id="addGuestBtn">
              <i class="me-2">âž•</i>Add New Guest
            </button>
            </div>
          <input type="text" id="people-search-input" class="form-control mb-3" placeholder="Search guests">
          <div id="people-list"></div>
        </div>
      </div>
        
        <!-- Center: Table Plan Area -->
        <div id="canvas-container">
        <div id="table-plan" class="position-relative">
          <!-- The zoomable and pannable canvas -->
          <div id="canvas"></div>
        </div>
      </div>
        
        <!-- Right: Assigned Guests Section -->
        <div class="sidebar" id="assigned-sidebar" data-title="Assigned Guests">
          <div id="assigned-container">
            <div class="sidebar-header">
              <h5>Assigned Guests</h5>
              <button class="btn btn-sm btn-outline-secondary sidebar-toggle" id="assigned-toggle" title="Collapse sidebar">
                <span class="toggle-icon">â–¶</span>
              </button>
            </div>
            <div id="assigned-guests-list"></div>
          </div>
        </div>
    </div>
  </div>

  <!-- Modal for Creating a New Table -->
  <div class="modal fade" id="newTableModal" tabindex="-1" aria-labelledby="newTableModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
         <div class="modal-header">
           <h5 class="modal-title" id="newTableModalLabel">Create New Table</h5>
           <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
         </div>
         <div class="modal-body">
           <form id="newTableForm">
             <div class="mb-3">
               <label for="tableName" class="form-label">Table Name</label>
               <input type="text" class="form-control" id="tableName" required>
             </div>
             <div class="mb-3">
               <label for="tableType" class="form-label">Table Type</label>
               <select class="form-select" id="tableType">
                 <option value="circle">Circle</option>
                 <option value="rectangle">Rectangle</option>
                 <option value="rectangle-long">Rectangle (Long)</option>
               </select>
             </div>
             <div class="mb-3">
               <label for="seatCount" class="form-label">Number of Seats</label>
               <input type="number" class="form-control" id="seatCount" value="8" min="1" required>
             </div>
             <button type="submit" class="btn btn-primary">Create Table</button>
           </form>
         </div>
      </div>
    </div>
  </div>

  <!-- Modal for Assigning a Guest to a Seat -->
  <div class="modal fade" id="assignmentModal" tabindex="-1" aria-labelledby="assignmentModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
         <div class="modal-header">
           <h5 class="modal-title" id="assignmentModalLabel">Assign Guest</h5>
           <button type="button" class="btn btn-danger" id="clearSeatBtn" style="display: none;     margin-left: 200px;">Clear Seat</button>
           <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
         </div>
         <div class="modal-body">
           <input type="text" id="assignmentSearch" class="form-control mb-3" placeholder="Search guests">
           <ul class="list-group" id="assignmentList"></ul>
         </div>
      </div>
    </div>
  </div>

  <!-- Modal for Creating/Editing Guest Profile -->
  <div class="modal fade" id="guestProfileModal" tabindex="-1" aria-labelledby="guestProfileModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
         <div class="modal-header">
           <h5 class="modal-title" id="guestProfileModalLabel">Guest Profile</h5>
           <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
         </div>
         <div class="modal-body">
           <form id="guestProfileForm">
             <div class="row">
               <div class="col-md-6">
                 <div class="mb-3">
                   <label for="guestName" class="form-label">Name *</label>
                   <input type="text" class="form-control" id="guestName" required>
                 </div>
                 <div class="mb-3">
                   <label for="guestEmail" class="form-label">Email</label>
                   <input type="email" class="form-control" id="guestEmail">
                 </div>
                 <div class="mb-3">
                   <label for="guestPhone" class="form-label">Phone</label>
                   <input type="tel" class="form-control" id="guestPhone">
                 </div>
               </div>
               <div class="col-md-6">
                 <div class="mb-3">
                   <label for="guestDietary" class="form-label">Dietary Requirements</label>
                   <select class="form-select" id="guestDietary">
                     <option value="">None</option>
                     <option value="Vegetarian">Vegetarian</option>
                     <option value="Vegan">Vegan</option>
                     <option value="Gluten Free">Gluten Free</option>
                     <option value="Dairy Free">Dairy Free</option>
                     <option value="Nut Free">Nut Free</option>
                     <option value="Halal">Halal</option>
                     <option value="Kosher">Kosher</option>
                     <option value="Other">Other</option>
                   </select>
                 </div>
                 <div class="mb-3">
                   <label for="guestPlusOne" class="form-label">Plus One</label>
                   <select class="form-select" id="guestPlusOne">
                     <option value="No">No</option>
                     <option value="Yes">Yes</option>
                   </select>
                 </div>
                 <div class="mb-3">
                   <label for="guestNotes" class="form-label">Notes</label>
                   <textarea class="form-control" id="guestNotes" rows="3" placeholder="Any additional notes about this guest..."></textarea>
                 </div>
               </div>
             </div>
           </form>
         </div>
         <div class="modal-footer">
           <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
           <button type="button" class="btn btn-primary" id="saveGuestProfileBtn">Save Guest</button>
         </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap Bundle JS (includes Popper) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- External CSS -->
  <link rel="stylesheet" href="styles.css">
  <!-- External JavaScript Modules -->
  <script src="js/canvas.js"></script>
  <script src="js/drag-drop.js"></script>
  <script>
        // Mobile-specific enhancements
    function initMobileFeatures() {
      const isMobile = window.innerWidth <= 767;
      
      // Show/hide appropriate instructions
      const desktopInstructions = document.querySelector('.desktop-instructions');
      const mobileInstructions = document.querySelector('.mobile-instructions');
      
      if (isMobile) {
        if (desktopInstructions) desktopInstructions.style.display = 'none';
        if (mobileInstructions) mobileInstructions.style.display = 'block';
        
        // Initialize mobile drawer navigation
        initMobileDrawers();
      } else {
        if (desktopInstructions) desktopInstructions.style.display = 'block';
        if (mobileInstructions) mobileInstructions.style.display = 'none';
        
        // Remove mobile navigation elements and ensure backdrop is cleared
        removeMobileDrawers();
        
        // Force clear any remaining backdrop
        const backdrop = document.getElementById('sidebar-backdrop');
        if (backdrop) {
          backdrop.classList.remove('active');
          backdrop.remove();
        }
        document.body.style.overflow = '';
      }
    }
    
    // Mobile drawer navigation
    function initMobileDrawers() {
      // Remove existing mobile nav if any
      removeMobileDrawers();
      
      // Ensure sidebars are properly positioned for mobile
      const unassignedSidebar = document.getElementById('unassigned-sidebar');
      const assignedSidebar = document.getElementById('assigned-sidebar');
      
      if (unassignedSidebar) {
        unassignedSidebar.style.position = 'fixed';
        unassignedSidebar.style.left = '0';
        unassignedSidebar.style.top = '0';
        unassignedSidebar.style.height = '100vh';
        unassignedSidebar.style.width = '280px';
        unassignedSidebar.style.maxWidth = '85vw';
        unassignedSidebar.style.zIndex = '1050';
        unassignedSidebar.style.transform = 'translateX(-100%)';
        unassignedSidebar.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        unassignedSidebar.style.boxShadow = '2px 0 10px rgba(0, 0, 0, 0.2)';
        unassignedSidebar.style.borderRadius = '0';
        unassignedSidebar.style.margin = '0';
        unassignedSidebar.style.display = 'block';
      }
      
      if (assignedSidebar) {
        assignedSidebar.style.position = 'fixed';
        assignedSidebar.style.left = 'auto';
        assignedSidebar.style.right = '0';
        assignedSidebar.style.top = '0';
        assignedSidebar.style.height = '100vh';
        assignedSidebar.style.width = '280px';
        assignedSidebar.style.maxWidth = '85vw';
        assignedSidebar.style.zIndex = '1050';
        assignedSidebar.style.transform = 'translateX(100%)';
        assignedSidebar.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        assignedSidebar.style.boxShadow = '-2px 0 10px rgba(0, 0, 0, 0.2)';
        assignedSidebar.style.borderRadius = '0';
        assignedSidebar.style.margin = '0';
        assignedSidebar.style.display = 'block';
      }
      
      // Create backdrop
      const backdrop = document.createElement('div');
      backdrop.className = 'sidebar-backdrop';
      backdrop.id = 'sidebar-backdrop';
      document.body.appendChild(backdrop);
      
      // Create navigation buttons
      const leftNavBtn = document.createElement('button');
      leftNavBtn.className = 'mobile-nav-btn left';
      leftNavBtn.innerHTML = 'ðŸ‘¥';
      leftNavBtn.title = 'Unassigned Guests';
      leftNavBtn.addEventListener('click', () => openMobileSidebar('unassigned-sidebar'));
      
      const rightNavBtn = document.createElement('button');
      rightNavBtn.className = 'mobile-nav-btn right';
      rightNavBtn.innerHTML = 'ðŸ“‹';
      rightNavBtn.title = 'Assigned Guests';
      rightNavBtn.addEventListener('click', () => openMobileSidebar('assigned-sidebar'));
      
      document.body.appendChild(leftNavBtn);
      document.body.appendChild(rightNavBtn);
      
      // Add backdrop click handler
      backdrop.addEventListener('click', closeAllMobileSidebars);
      
      // Add swipe gestures
      initSwipeGestures();
    }
    
    function removeMobileDrawers() {
      const backdrop = document.getElementById('sidebar-backdrop');
      const leftBtn = document.querySelector('.mobile-nav-btn.left');
      const rightBtn = document.querySelector('.mobile-nav-btn.right');
      
      // Clear backdrop first
      if (backdrop) {
        backdrop.classList.remove('active');
        backdrop.remove();
      }
      if (leftBtn) leftBtn.remove();
      if (rightBtn) rightBtn.remove();
      
      // Reset sidebar styles for desktop
      const unassignedSidebar = document.getElementById('unassigned-sidebar');
      const assignedSidebar = document.getElementById('assigned-sidebar');
      
      if (unassignedSidebar) {
        unassignedSidebar.style.position = '';
        unassignedSidebar.style.left = '';
        unassignedSidebar.style.top = '';
        unassignedSidebar.style.height = '';
        unassignedSidebar.style.width = '';
        unassignedSidebar.style.maxWidth = '';
        unassignedSidebar.style.zIndex = '';
        unassignedSidebar.style.transform = '';
        unassignedSidebar.style.transition = '';
        unassignedSidebar.style.boxShadow = '';
        unassignedSidebar.style.borderRadius = '';
        unassignedSidebar.style.margin = '';
        unassignedSidebar.style.display = '';
      }
      
      if (assignedSidebar) {
        assignedSidebar.style.position = '';
        assignedSidebar.style.left = '';
        assignedSidebar.style.right = '';
        assignedSidebar.style.top = '';
        assignedSidebar.style.height = '';
        assignedSidebar.style.width = '';
        assignedSidebar.style.maxWidth = '';
        assignedSidebar.style.zIndex = '';
        assignedSidebar.style.transform = '';
        assignedSidebar.style.transition = '';
        assignedSidebar.style.boxShadow = '';
        assignedSidebar.style.borderRadius = '';
        assignedSidebar.style.margin = '';
        assignedSidebar.style.display = '';
      }
      
      // Reset body overflow
      document.body.style.overflow = '';
      
      // Close any open sidebars
      closeAllMobileSidebars();
    }
    
    function openMobileSidebar(sidebarId) {
      const sidebar = document.getElementById(sidebarId);
      const backdrop = document.getElementById('sidebar-backdrop');
      
      if (sidebar && backdrop) {
        // Reset any existing transforms
        sidebar.style.transform = '';
        
        // Apply the open transform
        if (sidebarId === 'unassigned-sidebar') {
          sidebar.style.transform = 'translateX(0)';
        } else if (sidebarId === 'assigned-sidebar') {
          sidebar.style.transform = 'translateX(0)';
        }
        
        backdrop.classList.add('active');
        document.body.style.overflow = 'hidden';
      }
    }
    
    function closeAllMobileSidebars() {
      const sidebars = document.querySelectorAll('.sidebar');
      const backdrop = document.getElementById('sidebar-backdrop');
      
      sidebars.forEach(sidebar => {
        if (sidebar.id === 'unassigned-sidebar') {
          sidebar.style.transform = 'translateX(-100%)';
        } else if (sidebar.id === 'assigned-sidebar') {
          sidebar.style.transform = 'translateX(100%)';
        }
      });
      
      if (backdrop) {
        backdrop.classList.remove('active');
      }
      
      document.body.style.overflow = '';
    }
    
    // Swipe gestures for mobile
    function initSwipeGestures() {
      let startX = 0;
      let startY = 0;
      let isSwiping = false;
      
      document.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        isSwiping = false;
      });
      
      document.addEventListener('touchmove', (e) => {
        if (!startX || !startY) return;
        
        const deltaX = e.touches[0].clientX - startX;
        const deltaY = e.touches[0].clientY - startY;
        
        // Check if it's a horizontal swipe
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
          isSwiping = true;
          
          // Right swipe from left edge opens unassigned sidebar
          if (deltaX > 0 && startX < 50) {
            openMobileSidebar('unassigned-sidebar');
          }
          // Left swipe from right edge opens assigned sidebar
          else if (deltaX < 0 && startX > window.innerWidth - 50) {
            openMobileSidebar('assigned-sidebar');
          }
        }
      });
      
      document.addEventListener('touchend', () => {
        startX = 0;
        startY = 0;
        isSwiping = false;
      });
    }
    
    // Initialize mobile features
    document.addEventListener('DOMContentLoaded', initMobileFeatures);
    window.addEventListener('resize', initMobileFeatures);
    
    // CSV template download functionality
    document.addEventListener('DOMContentLoaded', function() {
      const downloadTemplateBtn = document.getElementById('download-template-btn');
      if (downloadTemplateBtn) {
        downloadTemplateBtn.addEventListener('click', function() {
          // Create CSV content
          const csvContent = `Name,Email,Phone,Dietary Requirements,Plus One,Notes
John Smith,john.smith@email.com,555-0123,None,Yes,Close friend
Jane Doe,jane.doe@email.com,555-0124,Vegetarian,No,College roommate
Bob Johnson,bob.johnson@email.com,555-0125,Gluten Free,Yes,Work colleague
Sarah Wilson,sarah.wilson@email.com,555-0126,None,No,Family member
Mike Brown,mike.brown@email.com,555-0127,Vegan,Yes,Childhood friend`;
          
          // Create download link
          const blob = new Blob([csvContent], { type: 'text/csv' });
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'guest_import_template.csv';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        });
      }
    });
  </script>
  <script>
    /* ============================
       Constants
    ============================ */
    const SEAT_R = 20; // half of .seat 40 px diameter
    
    /* ============================
       Guest (Person) Handling and Controls
    ============================ */
    let personCounter = 0;
    let guestData = new Map(); // Store guest data with all fields
  let guestDataByName = new Map(); // Store guest data by name (handles duplicates)
    
    function addPerson(guestInfo) {
      personCounter++;
      const person = document.createElement('div');
      person.className = 'person';
      person.id = 'person-' + personCounter;
      person.draggable = true;
      person.addEventListener('dragstart', window.dragDropModule.handleDragStart);
      person.addEventListener('dragend', window.dragDropModule.handlePersonDragEnd);
      
      // Handle both string (name only) and object (full guest data)
      const name = typeof guestInfo === 'string' ? guestInfo : guestInfo.name;
      const email = typeof guestInfo === 'string' ? '' : (guestInfo.email || '');
      const phone = typeof guestInfo === 'string' ? '' : (guestInfo.phone || '');
      const dietary = typeof guestInfo === 'string' ? '' : (guestInfo.dietary || '');
      const plusOne = typeof guestInfo === 'string' ? 'No' : (guestInfo.plusOne || 'No');
      const notes = typeof guestInfo === 'string' ? '' : (guestInfo.notes || '');
      
      // Clean the name to remove any dietary symbols
      const cleanName = name.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
      
      // Use existing ID if available, otherwise create new one
      const guestId = (typeof guestInfo === 'object' && guestInfo.id) ? guestInfo.id : 'person-' + personCounter;
      const guestDataObj = {
        id: guestId,
        name: cleanName,
        email: email,
        phone: phone,
        dietary: dietary,
        plusOne: plusOne,
        notes: notes
      };
      guestData.set(guestId, guestDataObj);
      
      // Also store by name for easier lookup (handles duplicates)
      if (!guestDataByName.has(cleanName)) {
        guestDataByName.set(cleanName, []);
      }
      guestDataByName.get(cleanName).push(guestDataObj);
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'guest-name';
      nameSpan.textContent = cleanName;
      
      // Add dietary indicator if present
      if (dietary && dietary !== '') {
        const dietaryIcon = document.createElement('span');
        dietaryIcon.className = 'dietary-indicator';
        dietaryIcon.innerHTML = 'ðŸ¥—';
        dietaryIcon.title = `Dietary: ${dietary}`;
        nameSpan.appendChild(dietaryIcon);
      }
      
      const controls = document.createElement('div');
      controls.className = 'guest-controls';
      const editBtn = document.createElement('button');
      editBtn.title = "Edit guest profile";
      editBtn.innerHTML = "âœŽ";
      editBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        openGuestProfileModal(guestId, true);
      });
      controls.appendChild(editBtn);
      
      const removeBtn = document.createElement('button');
      removeBtn.title = "Remove guest";
      removeBtn.innerHTML = "âœ–";
      removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm("Remove this guest?")) {
          guestData.delete(guestId);
          person.remove();
          updateCounts();
        }
      });
      controls.appendChild(removeBtn);
      
      person.appendChild(document.createElement('span')).innerHTML = '<span class="person-icon">ðŸ‘¤</span>';
      person.appendChild(nameSpan);
      person.appendChild(controls);
      
      // Add touch listeners for mobile drag and drop
      if (window.dragDropModule && window.dragDropModule.addTouchListeners) {
        window.dragDropModule.addTouchListeners(person);
      }
      
      document.getElementById('people-list').appendChild(person);
      updateCounts();
    }
    
    // Guest profile modal functionality
    let editingGuestId = null;
    
    function openGuestProfileModal(guestId = null, isEditing = false) {
      editingGuestId = guestId;
      const modal = new bootstrap.Modal(document.getElementById('guestProfileModal'));
      const form = document.getElementById('guestProfileForm');
      const title = document.getElementById('guestProfileModalLabel');
      
      // Reset form
      form.reset();
      
      if (isEditing && guestId && guestData.has(guestId)) {
        // Editing existing guest
        const guest = guestData.get(guestId);
        title.textContent = 'Edit Guest Profile';
        document.getElementById('guestName').value = guest.name.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
        document.getElementById('guestEmail').value = guest.email;
        document.getElementById('guestPhone').value = guest.phone;
        document.getElementById('guestDietary').value = guest.dietary;
        document.getElementById('guestPlusOne').value = guest.plusOne;
        document.getElementById('guestNotes').value = guest.notes;
      } else {
        // Creating new guest
        title.textContent = 'Add New Guest';
        editingGuestId = null;
      }
      
      modal.show();
      
      // Focus management for accessibility
      setTimeout(() => {
        const firstInput = document.getElementById('guestName');
        if (firstInput) {
          firstInput.focus();
        }
      }, 100);
    }
    
    // Save guest profile
    document.getElementById('saveGuestProfileBtn').addEventListener('click', function() {
      const form = document.getElementById('guestProfileForm');
      const name = document.getElementById('guestName').value.trim();
      
      if (!name) {
        alert('Guest name is required');
        return;
      }
      
      const guestInfo = {
        name: name,
        email: document.getElementById('guestEmail').value.trim(),
        phone: document.getElementById('guestPhone').value.trim(),
        dietary: document.getElementById('guestDietary').value,
        plusOne: document.getElementById('guestPlusOne').value,
        notes: document.getElementById('guestNotes').value.trim()
      };
      
      if (editingGuestId && guestData.has(editingGuestId)) {
        // Update existing guest
        guestData.set(editingGuestId, { ...guestData.get(editingGuestId), ...guestInfo });
        updateGuestDisplay(editingGuestId);
        
        // Update assigned guests display if this guest is assigned to a table
        updateAssignedGuestsDisplay();
      } else {
        // Create new guest
        addPerson(guestInfo);
        // Update assigned guests display in case this guest gets assigned
        updateAssignedGuestsDisplay();
      }
      
      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('guestProfileModal'));
      modal.hide();
      
      updateCounts();
    });
    
    // Add guest button functionality
    document.getElementById('addGuestBtn').addEventListener('click', function() {
      openGuestProfileModal(null, false);
    });
    
    function updateGuestDisplay(guestId) {
      const person = document.getElementById(guestId);
      if (!person) return;
      
      const guest = guestData.get(guestId);
      if (!guest) return;
      
      const nameSpan = person.querySelector('.guest-name');
      
      // Clear existing content and set clean name (remove any dietary symbols that might have been saved)
      nameSpan.innerHTML = '';
      const cleanName = guest.name.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
      nameSpan.textContent = cleanName;
      
      // Update the guest data with the clean name
      guestData.set(guestId, { ...guest, name: cleanName });
      
      // Add dietary indicator if present
      if (guest.dietary && guest.dietary !== '') {
        const dietaryIcon = document.createElement('span');
        dietaryIcon.className = 'dietary-indicator';
        dietaryIcon.innerHTML = 'ðŸ¥—';
        dietaryIcon.title = `Dietary: ${guest.dietary}`;
        nameSpan.appendChild(dietaryIcon);
      }
      
      // Update tooltips
      updateTooltipsForPerson(person);
      
      // Update assigned guests display to reflect changes
      updateAssignedGuestsDisplay();
    }
    
    // Function to update all guest displays (useful after import)
    function updateAllGuestDisplays() {
      for (let [guestId, guest] of guestData) {
        updateGuestDisplay(guestId);
      }
    }
    
    function createPersonElement(guestInfo) {
      personCounter++;
      const person = document.createElement('div');
      person.className = 'person';
      
      // Handle both string (name only) and object (full guest data)
      const name = typeof guestInfo === 'string' ? guestInfo : guestInfo.name;
      const email = typeof guestInfo === 'string' ? '' : (guestInfo.email || '');
      const phone = typeof guestInfo === 'string' ? '' : (guestInfo.phone || '');
      const dietary = typeof guestInfo === 'string' ? '' : (guestInfo.dietary || '');
      const plusOne = typeof guestInfo === 'string' ? 'No' : (guestInfo.plusOne || 'No');
      const notes = typeof guestInfo === 'string' ? '' : (guestInfo.notes || '');
      
      // Clean the name to remove any dietary symbols
      const cleanName = name.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
      
      // Use existing ID if available, otherwise create new one
      const guestId = (typeof guestInfo === 'object' && guestInfo.id) ? guestInfo.id : 'person-' + personCounter;
      person.id = guestId;
      person.draggable = true;
      person.addEventListener('dragstart', window.dragDropModule.handleDragStart);
      person.addEventListener('dragend', window.dragDropModule.handlePersonDragEnd);
      
      // Store guest data
      const guestDataObj = {
        id: guestId,
        name: cleanName,
        email: email,
        phone: phone,
        dietary: dietary,
        plusOne: plusOne,
        notes: notes
      };
      guestData.set(guestId, guestDataObj);
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'guest-name';
      nameSpan.textContent = cleanName;
      
      // Add dietary indicator if present
      if (dietary && dietary !== '') {
        const dietaryIcon = document.createElement('span');
        dietaryIcon.className = 'dietary-indicator';
        dietaryIcon.innerHTML = 'ðŸ¥—';
        dietaryIcon.title = `Dietary: ${dietary}`;
        nameSpan.appendChild(dietaryIcon);
      }
      
      const controls = document.createElement('div');
      controls.className = 'guest-controls';
      const editBtn = document.createElement('button');
      editBtn.title = "Edit guest profile";
      editBtn.innerHTML = "âœŽ";
      editBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        openGuestProfileModal(guestId, true);
      });
      controls.appendChild(editBtn);
      
      const removeBtn = document.createElement('button');
      removeBtn.title = "Remove guest";
      removeBtn.innerHTML = "âœ–";
      removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm("Remove this guest?")) {
          guestData.delete(guestId);
          person.remove();
          updateCounts();
        }
      });
      controls.appendChild(removeBtn);
      
      person.appendChild(document.createElement('span')).innerHTML = '<span class="person-icon">ðŸ‘¤</span>';
      person.appendChild(nameSpan);
      person.appendChild(controls);
      
      // Add touch listeners for mobile drag and drop
      if (window.dragDropModule && window.dragDropModule.addTouchListeners) {
        window.dragDropModule.addTouchListeners(person);
      }
      
      return person;
    }
    
    /* ============================
       CSV Import for Guests
    ============================ */
    document.getElementById('csv-file').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const text = e.target.result;
        parseGuestCSV(text);
      }
      reader.readAsText(file);
    });
    function parseGuestCSV(text) {
      const lines = text.split('\n');
      
      // Clear existing people and guest data
      document.getElementById('people-list').innerHTML = '';
      guestData.clear();
      personCounter = 0;
      
      // Skip header row and process each line
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === '') continue;
        
        const columns = line.split(',').map(col => col.trim().replace(/^"|"$/g, ''));
        const name = columns[0] || '';
        
        if (name) {
          const guestInfo = {
            name: name,
            email: columns[1] || '',
            phone: columns[2] || '',
            dietary: columns[3] || '',
            plusOne: columns[4] || 'No',
            notes: columns[5] || ''
          };
          addPerson(guestInfo);
        }
      }
    }
    
    /* ============================
       Search in Unassigned People
    ============================ */
    document.getElementById('people-search-input').addEventListener('input', function() {
      const query = this.value.toLowerCase();
      const persons = peopleList.getElementsByClassName('person');
      for (let person of persons) {
        person.style.display = person.textContent.toLowerCase().includes(query) ? 'flex' : 'none';
      }
    });
    
    /* ============================
       Tooltip Management
    ============================ */
    function cleanGuestName(person) {
      // Clean the guest name by removing edit button characters and ensuring proper structure
      const nameSpan = person.querySelector('.guest-name');
      if (nameSpan) {
        const currentText = nameSpan.textContent;
        const cleanName = currentText.replace(/[âœŽâœ–]/g, '').trim();
        if (currentText !== cleanName) {
          nameSpan.textContent = cleanName;
        }
      }
    }
    
    // Make cleanGuestName available globally
    window.cleanGuestName = cleanGuestName;
    
    // Function to clean all guest names in the unassigned list
    function cleanAllGuestNames() {
      const unassignedPersons = document.querySelectorAll('#people-list .person');
      unassignedPersons.forEach(person => {
        cleanGuestName(person);
      });
    }
    
    // Make cleanAllGuestNames available globally
    window.cleanAllGuestNames = cleanAllGuestNames;
    
    function updateTooltipsForPerson(person) {
      // Clean the guest name first
      cleanGuestName(person);
      
      // Find all seats that contain this person and update their tooltips
      const seats = document.querySelectorAll('#canvas .table.card .card-body .seat');
      seats.forEach(seat => {
        if (seat.children.length > 0 && seat.children[0] === person) {
          let guestName = person.querySelector('.guest-name')?.textContent || 'Unknown Guest';
          guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
          seat.setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
          seat.title = `${guestName} (Click to edit, drag to move)`;
        }
      });
    }
    
    /* ============================
       Guest/Seat Count Display
    ============================ */
    function updateCounts() {
      // Clean all guest names first to ensure consistency
      if (window.cleanAllGuestNames) {
        window.cleanAllGuestNames();
      }
      
      const allPersons = document.querySelectorAll('.person');
      const totalGuests = allPersons.length;
      let totalSeats = 0;
      document.querySelectorAll('#canvas .table.card').forEach(table => {
        totalSeats += parseInt(table.dataset.seatCount) || 0;
      });
      const countDiv = document.getElementById('guestSeatCounts');
      countDiv.innerHTML = `Total Guests: ${totalGuests} &nbsp;&nbsp; Total Seats: <span class="${totalGuests > totalSeats ? 'seat-count over' : 'seat-count'}">${totalSeats}</span>`;
      
      // Update assigned guests display
      updateAssignedGuestsDisplay();
    }
    
    /* ============================
       Assigned Guests Display
    ============================ */
    function updateAssignedGuestsDisplay() {
      const assignedContainer = document.getElementById('assigned-guests-list');
      
      // Store the current expanded state of tables
      const expandedTables = new Set();
      const existingTables = assignedContainer.querySelectorAll('.table-assignment');
      existingTables.forEach(tableDiv => {
        const tableName = tableDiv.dataset.tableName;
        const content = tableDiv.querySelector('.table-assignment-content');
        if (content && content.classList.contains('expanded')) {
          expandedTables.add(tableName);
        }
      });
      
      assignedContainer.innerHTML = '';
      
      const tables = document.querySelectorAll('#canvas .table.card');
      const tablesWithGuests = [];
      
      tables.forEach(table => {
        const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent || 'Unknown Table';
        const seats = table.querySelectorAll('.card-body .seat');
        const assignedGuests = [];
        
        seats.forEach((seat, index) => {
          if (seat.children.length > 0) {
            let guestName = seat.children[0].querySelector('.guest-name')?.textContent || 'Unknown Guest';
            // Clean the guest name by removing edit button characters
            guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
            assignedGuests.push({
              name: guestName,
              seatIndex: index + 1,
              personElement: seat.children[0],
              isAssigned: true
            });
          } else {
            // Add empty seat
            assignedGuests.push({
              name: 'Empty',
              seatIndex: index + 1,
              personElement: null,
              isAssigned: false
            });
          }
        });
        
        // Only add tables that have seats (all tables will have seats)
        tablesWithGuests.push({
          name: tableName,
          guests: assignedGuests
        });
      });
      
      if (tablesWithGuests.length === 0) {
        assignedContainer.innerHTML = '<p class="text-muted text-center">No tables created yet.</p>';
        return;
      }
      
      tablesWithGuests.forEach(tableData => {
        const tableDiv = document.createElement('div');
        tableDiv.className = 'table-assignment';
        tableDiv.draggable = true;
        tableDiv.dataset.tableName = tableData.name;
        
        const header = document.createElement('div');
        header.className = 'table-assignment-header';
        
        // Count assigned guests
        const assignedCount = tableData.guests.filter(guest => guest.isAssigned).length;
        const totalSeats = tableData.guests.length;
        
        header.innerHTML = `
          <div style="display: flex; align-items: center; gap: 8px;">
            <span class="drag-handle">â‹®â‹®</span>
            <span class="table-name">${tableData.name}</span>
          </div>
          <span class="guest-count">${assignedCount}/${totalSeats}</span>
        `;
        
        const content = document.createElement('div');
        content.className = 'table-assignment-content';
        
        tableData.guests.forEach(guest => {
          const guestItem = document.createElement('div');
          guestItem.className = 'guest-item';
          
          if (guest.isAssigned) {
            // Clean the guest name to remove any edit/delete symbols and dietary indicators
            const cleanGuestName = guest.name.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
            
            // Find the guest data to check for dietary requirements
            let dietaryIndicator = '';
            if (guest.personElement && guest.personElement.id) {
              const guestDataObj = guestData.get(guest.personElement.id);
              if (guestDataObj && guestDataObj.dietary && guestDataObj.dietary !== '') {
                dietaryIndicator = 'ðŸ¥—';
              }
            }
            
            guestItem.innerHTML = `
              <div class="guest-info">
                <span class="drag-handle-guest" title="Drag to reorder">â‹®â‹®</span>
                <span class="guest-name" style="cursor: pointer;">${cleanGuestName}${dietaryIndicator ? ' ' + dietaryIndicator : ''}</span>
              </div>
              <div class="guest-controls">
                <button class="edit-guest-btn" title="Edit guest profile">âœŽ</button>
                <button class="remove-guest-btn" title="Remove from table">âœ–</button>
              </div>
            `;
            
            // Make assigned guests draggable for reordering and moving to unassigned
            guestItem.draggable = true;
            guestItem.dataset.guestName = guest.name;
            guestItem.dataset.seatIndex = guest.seatIndex;
            guestItem.dataset.tableName = tableData.name;
            guestItem.dataset.personId = guest.personElement.id;
            
            // Add drag and drop event listeners
            guestItem.addEventListener('dragstart', handleGuestDragStart);
            guestItem.addEventListener('dragend', handleGuestDragEnd);
            guestItem.addEventListener('dragover', handleGuestDragOver);
            guestItem.addEventListener('dragenter', handleGuestDragEnter);
            guestItem.addEventListener('dragleave', handleGuestDragLeave);
            guestItem.addEventListener('drop', handleGuestDrop);
            
            // Add touch support for guest reordering (touch and hold on the guest item)
            guestItem.addEventListener('touchstart', handleGuestTouchStart, { passive: true });
            guestItem.addEventListener('touchmove', handleGuestTouchMove, { passive: true });
            guestItem.addEventListener('touchend', handleGuestTouchEnd, { passive: true });
            
            // Add hover highlighting for assigned guests
            const guestNameSpan = guestItem.querySelector('.guest-name');
            guestNameSpan.addEventListener('mouseenter', function(e) {
              // Don't highlight if we're dragging (check both old and new dragging systems)
              if (draggedGuest || draggedTable || guestTouchDragging || tableTouchDragging) {
                return;
              }
              
              // Check dragDropModule only if it exists and has the property
              if (window.dragDropModule && typeof window.dragDropModule.isDragging === 'function' && window.dragDropModule.isDragging()) {
                return;
              }
              
              // Find the corresponding seat on the canvas and highlight it
              const tables = document.querySelectorAll('#canvas .table.card');
              let found = false;
              tables.forEach((table, index) => {
                const tableTitle = table.querySelector('.table-title')?.textContent;
                const tableName = table.querySelector('.table-name')?.textContent;
                const tableNameFinal = tableTitle || tableName;
                
                if (tableNameFinal === tableData.name) {
                  const seats = table.querySelectorAll('.card-body .seat');
                  const targetSeat = seats[guest.seatIndex - 1];
                  if (targetSeat) {
                    // Remove any existing highlights first
                    document.querySelectorAll('.highlighted-seat').forEach(seat => {
                      seat.classList.remove('highlighted-seat');
                    });
                    // Add highlight to the target seat
                    targetSeat.classList.add('highlighted-seat');
                    found = true;
                  }
                }
              });
            });
            
            guestNameSpan.addEventListener('mouseleave', function(e) {
              // Remove highlighting from all seats
              const allSeats = document.querySelectorAll('#canvas .table.card .card-body .seat');
              allSeats.forEach(seat => {
                seat.classList.remove('highlighted-seat');
              });
            });
            
            // Also add mouseenter to the entire guest item for better hover detection
            guestItem.addEventListener('mouseenter', function(e) {
              // Don't highlight if we're dragging (check both old and new dragging systems)
              if (draggedGuest || draggedTable || guestTouchDragging || tableTouchDragging) {
                return;
              }
              
              // Check dragDropModule only if it exists and has the property
              if (window.dragDropModule && typeof window.dragDropModule.isDragging === 'function' && window.dragDropModule.isDragging()) {
                return;
              }
              
              // Find the corresponding seat on the canvas and highlight it
              const tables = document.querySelectorAll('#canvas .table.card');
              let found = false;
              tables.forEach((table, index) => {
                const tableTitle = table.querySelector('.table-title')?.textContent;
                const tableName = table.querySelector('.table-name')?.textContent;
                const tableNameFinal = tableTitle || tableName;
                
                if (tableNameFinal === tableData.name) {
                  const seats = table.querySelectorAll('.card-body .seat');
                  const targetSeat = seats[guest.seatIndex - 1];
                  if (targetSeat) {
                    // Remove any existing highlights first
                    document.querySelectorAll('.highlighted-seat').forEach(seat => {
                      seat.classList.remove('highlighted-seat');
                    });
                    // Add highlight to the target seat
                    targetSeat.classList.add('highlighted-seat');
                    found = true;
                  }
                }
              });
            });
            
            guestItem.addEventListener('mouseleave', function(e) {
              // Remove highlighting from all seats
              const allSeats = document.querySelectorAll('#canvas .table.card .card-body .seat');
              allSeats.forEach(seat => {
                seat.classList.remove('highlighted-seat');
              });
            });
            
            // Add click and touch handlers to edit guest name
            const editBtn = guestItem.querySelector('.edit-guest-btn');
            
            function handleEditClick(e) {
              e.stopPropagation(); // Prevent triggering the header click
              e.preventDefault();
              
              // Find the actual guest element on the canvas to get its ID
              let guestId = null;
              const tables = document.querySelectorAll('#canvas .table.card');
              tables.forEach(table => {
                const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
                if (tableName === tableData.name) {
                  const seats = table.querySelectorAll('.card-body .seat');
                  if (seats[guest.seatIndex - 1] && seats[guest.seatIndex - 1].children.length > 0) {
                    const personElement = seats[guest.seatIndex - 1].children[0];
                    guestId = personElement.id;
                  }
                }
              });
              
              // Open the guest profile modal
              if (guestId) {
                openGuestProfileModal(guestId, true);
              }
            }
            
            editBtn.addEventListener('click', handleEditClick);
            editBtn.addEventListener('touchend', handleEditClick, { passive: true });
            
            // Add click and touch handlers to remove guest from table
            const removeBtn = guestItem.querySelector('.remove-guest-btn');
            
            function handleRemoveClick(e) {
              e.stopPropagation(); // Prevent triggering the header click
              e.preventDefault();
              
              if (confirm(`Remove ${guest.name} from ${tableData.name}?`)) {
                // Find the actual seat and remove the guest
                const tables = document.querySelectorAll('#canvas .table.card');
                tables.forEach(table => {
                  const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
                  if (tableName === tableData.name) {
                    const seats = table.querySelectorAll('.card-body .seat');
                    if (seats[guest.seatIndex - 1] && seats[guest.seatIndex - 1].children.length > 0) {
                      const person = seats[guest.seatIndex - 1].children[0];
                      document.getElementById('people-list').appendChild(person);
                      seats[guest.seatIndex - 1].innerHTML = '';
                      seats[guest.seatIndex - 1].classList.remove('filled');
                      // Clear tooltip and title from the seat
                      seats[guest.seatIndex - 1].removeAttribute('data-tooltip');
                      seats[guest.seatIndex - 1].removeAttribute('title');
                      updateCounts();
                    }
                  }
                });
              }
            }
            
            removeBtn.addEventListener('click', handleRemoveClick);
            removeBtn.addEventListener('touchend', handleRemoveClick, { passive: true });
          } else {
            // Empty seat
            guestItem.innerHTML = `
              <span class="guest-name empty-seat">Seat ${guest.seatIndex}: Empty</span>
              <span class="drop-hint">Drop guest here or click to assign</span>
            `;
            guestItem.classList.add('empty-seat-item');
            guestItem.style.cursor = 'pointer';
            guestItem.title = 'Drop a guest here or click to assign them to this seat';
            
            // Add click handler to open assignment modal
            guestItem.addEventListener('click', function(e) {
              // Don't open modal if clicking on drop hint or if this is a drag operation
              if (e.target.classList.contains('drop-hint') || draggedGuest) {
                return;
              }
              
              // Find the actual seat on the canvas and open the assignment modal
              const tables = document.querySelectorAll('#canvas .table.card');
              tables.forEach(table => {
                const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
                if (tableName === tableData.name) {
                  const seats = table.querySelectorAll('.card-body .seat');
                  if (seats[guest.seatIndex - 1]) {
                    openAssignmentModal(seats[guest.seatIndex - 1]);
                  }
                }
              });
            });
            
            // Make empty seats droppable
            guestItem.addEventListener('dragover', function(e) {
      e.preventDefault();
              e.stopPropagation();
              if (isDragging && draggedElement) {
                this.classList.add('over');
              }
            });
            guestItem.addEventListener('dragleave', function(e) {
              e.stopPropagation();
              this.classList.remove('over');
            });
            guestItem.addEventListener('drop', function(e) {
              e.preventDefault();
              e.stopPropagation();
              this.classList.remove('over');
              
              const personId = e.dataTransfer.getData('text/plain');
              const personElem = document.getElementById(personId);
              
              if (personElem && isDragging) {
                // Find the actual seat on the canvas and assign the guest
                const tables = document.querySelectorAll('#canvas .table.card');
                tables.forEach(table => {
                  const tableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
                  if (tableName === tableData.name) {
                    const seats = table.querySelectorAll('.card-body .seat');
                    const targetSeat = seats[guest.seatIndex - 1];
                    if (targetSeat && !targetSeat.classList.contains('filled')) {
                      const sourceParent = personElem.parentElement;

                      // Remove from source if it was in a seat
                      if (sourceParent && sourceParent.classList.contains('seat')) {
                        sourceParent.classList.remove('filled');
                        sourceParent.removeAttribute('data-tooltip');
                        sourceParent.removeAttribute('title');
                      }

                      // Add guest to the new seat
                      targetSeat.innerHTML = '';
                      targetSeat.appendChild(personElem);
                      targetSeat.classList.add('filled');
                      
                      // Add tooltip to the seat element
                      let guestName = personElem.querySelector('.guest-name')?.textContent || 'Unknown Guest';
                      guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
                      targetSeat.setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
                      targetSeat.title = `${guestName} (Click to edit, drag to move)`;
                      
                              // Ensure the person element remains draggable
        personElem.draggable = true;
        personElem.addEventListener('dragstart', window.dragDropModule.handleDragStart);
        personElem.addEventListener('dragend', window.dragDropModule.handlePersonDragEnd);
                      
                      // Update the display
                      updateCounts();
                    }
                  }
                });
              }
            });
          }
          
          content.appendChild(guestItem);
        });
        
                // Add click handler to expand/collapse table (desktop only)
        header.addEventListener('click', function(e) {
          // Don't expand/collapse if clicking on control buttons
          if (e.target.classList.contains('remove-guest-btn') || 
              e.target.classList.contains('edit-guest-btn') ||
              e.target.closest('.guest-controls')) {
            return;
          }
          
          // Only handle clicks on desktop (mobile uses touchend)
          if (window.innerWidth > 768) {
            content.classList.toggle('expanded');
            header.classList.toggle('expanded');
            
            // Store expanded state
            if (content.classList.contains('expanded')) {
              expandedTables.add(tableData.name);
            } else {
              expandedTables.delete(tableData.name);
            }
          }
        });
        
        // Add touch handler for mobile expand/collapse
        header.addEventListener('touchend', function(e) {
          // Don't expand/collapse if touching control buttons
          if (e.target.classList.contains('remove-guest-btn') || 
              e.target.classList.contains('edit-guest-btn') ||
              e.target.closest('.guest-controls')) {
            return;
          }
          
          // Check if we were dragging (only if we actually moved significantly)
          if (tableTouchDragging && tableTouchElement === tableDiv) {
            return;
          }
          
          content.classList.toggle('expanded');
          header.classList.toggle('expanded');
          
          // Store expanded state
          if (content.classList.contains('expanded')) {
            expandedTables.add(tableData.name);
          } else {
            expandedTables.delete(tableData.name);
          }
        });
        
        // Add drag and drop functionality
        tableDiv.addEventListener('dragstart', handleTableDragStart);
        tableDiv.addEventListener('dragend', handleTableDragEnd);
        tableDiv.addEventListener('dragover', handleTableDragOver);
        tableDiv.addEventListener('dragenter', handleTableDragEnter);
        tableDiv.addEventListener('dragleave', handleTableDragLeave);
        tableDiv.addEventListener('drop', handleTableDrop);
        
        // Add touch support for table reordering
        tableDiv.addEventListener('touchstart', handleTableTouchStart, { passive: true });
        tableDiv.addEventListener('touchmove', handleTableTouchMove, { passive: true });
        tableDiv.addEventListener('touchend', handleTableTouchEnd, { passive: true });
        
        tableDiv.appendChild(header);
        tableDiv.appendChild(content);
        assignedContainer.appendChild(tableDiv);
        
        // Restore expanded state if this table was previously expanded
        if (expandedTables.has(tableData.name)) {
          content.classList.add('expanded');
          header.classList.add('expanded');
        }
      });
    }
    
    /* ============================
       Table Reordering Drag & Drop
    ============================ */
    let draggedTable = null;
    
    function handleTableDragStart(e) {
      // Don't start table drag if dragging a guest
      if (draggedGuest) {
        return;
      }
      draggedTable = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.outerHTML);
    }
    
    function handleTableDragEnd(e) {
      // Don't end table drag if dragging a guest
      if (draggedGuest) {
        return;
      }
      this.classList.remove('dragging');
      draggedTable = null;
    }
    
    function handleTableDragOver(e) {
      // Don't handle table drag over if dragging a guest
      if (draggedGuest) {
        return;
      }
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }
    
    function handleTableDragEnter(e) {
      // Don't handle table drag enter if dragging a guest
      if (draggedGuest) {
        return;
      }
      e.preventDefault();
      if (this !== draggedTable) {
        this.classList.add('drag-over');
      }
    }
    
    function handleTableDragLeave(e) {
      // Don't handle table drag leave if dragging a guest
      if (draggedGuest) {
        return;
      }
      this.classList.remove('drag-over');
    }
    
    function handleTableDrop(e) {
      // Don't handle table drop if dragging a guest
      if (draggedGuest) {
        return;
      }
      e.preventDefault();
      this.classList.remove('drag-over');
      
      if (draggedTable && this !== draggedTable) {
        const container = document.getElementById('assigned-guests-list');
        const allTables = Array.from(container.querySelectorAll('.table-assignment'));
        const draggedIndex = allTables.indexOf(draggedTable);
        const dropIndex = allTables.indexOf(this);
        
        if (draggedIndex < dropIndex) {
          // Moving down
          this.parentNode.insertBefore(draggedTable, this.nextSibling);
        } else {
          // Moving up
          this.parentNode.insertBefore(draggedTable, this);
        }
      }
    }
    
    /* ============================
       Guest Reordering Drag & Drop
    ============================ */
    let draggedGuest = null;
    
    function handleGuestDragStart(e) {
      e.stopPropagation(); // Prevent table drag from starting
      draggedGuest = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', this.dataset.personId);
    }
    
    function handleGuestDragEnd(e) {
      e.stopPropagation(); // Prevent table drag from ending
      this.classList.remove('dragging');
      draggedGuest = null;
    }
    
    function handleGuestDragOver(e) {
      e.preventDefault();
      e.stopPropagation(); // Prevent table drag over
      e.dataTransfer.dropEffect = 'move';
    }
    
    function handleGuestDragEnter(e) {
      e.preventDefault();
      e.stopPropagation(); // Prevent table drag enter
      if (this !== draggedGuest && this.dataset.tableName === draggedGuest?.dataset.tableName) {
        this.classList.add('drag-over');
      }
    }
    
    function handleGuestDragLeave(e) {
      e.stopPropagation(); // Prevent table drag leave
      this.classList.remove('drag-over');
    }
    
    function handleGuestDrop(e) {
      e.preventDefault();
      e.stopPropagation(); // Prevent table drop
      this.classList.remove('drag-over');
      
      if (draggedGuest && this !== draggedGuest && this.dataset.tableName === draggedGuest.dataset.tableName) {
        // Get the table content container
        const tableContent = this.closest('.table-assignment-content');
        const allGuests = Array.from(tableContent.querySelectorAll('.guest-item:not(.empty-seat-item)'));
        const draggedIndex = allGuests.indexOf(draggedGuest);
        const dropIndex = allGuests.indexOf(this);
        
        if (draggedIndex !== -1 && dropIndex !== -1) {
          // Reorder in the assigned guests list
          if (draggedIndex < dropIndex) {
            // Moving down
            this.parentNode.insertBefore(draggedGuest, this.nextSibling);
          } else {
            // Moving up
            this.parentNode.insertBefore(draggedGuest, this);
          }
          
          // Update the canvas to reflect the new order
          updateCanvasFromAssignedGuestsOrder(tableContent);
        }
      }
    }
    
    function updateCanvasFromAssignedGuestsOrder(tableContent) {
      const tableName = tableContent.closest('.table-assignment').dataset.tableName;
      const guestItems = tableContent.querySelectorAll('.guest-item:not(.empty-seat-item)');
      
      // Find the corresponding table on the canvas
      const tables = document.querySelectorAll('#canvas .table.card');
      tables.forEach(table => {
        const canvasTableName = table.querySelector('.table-title')?.textContent || table.querySelector('.table-name')?.textContent;
        if (canvasTableName === tableName) {
          const seats = table.querySelectorAll('.card-body .seat');
          
          // Clear all seats first
          seats.forEach(seat => {
            if (seat.children.length > 0) {
              const person = seat.children[0];
              document.getElementById('people-list').appendChild(person);
              seat.innerHTML = '';
              seat.classList.remove('filled');
              // Clear tooltip and title from the seat
              seat.removeAttribute('data-tooltip');
              seat.removeAttribute('title');
            }
          });
          
          // Reassign guests in the new order
          guestItems.forEach((guestItem, index) => {
            const guestName = guestItem.dataset.guestName;
            
            // Find the person element in the unassigned list by name
            const unassignedPersons = document.querySelectorAll('#people-list .person');
            let personElement = null;
            
            for (let person of unassignedPersons) {
              const nameSpan = person.querySelector('.guest-name');
              if (nameSpan) {
                // Clean the name for comparison (remove edit buttons)
                const cleanName = nameSpan.textContent.replace(/[âœŽâœ–]/g, '').trim();
                if (cleanName === guestName) {
                  personElement = person;
                  break;
                }
              }
            }
            
            if (personElement) {
              // Remove from unassigned list
              personElement.remove();
              
              // Add to the seat
              seats[index].innerHTML = '';
              seats[index].appendChild(personElement);
              seats[index].classList.add('filled');
              
              // Ensure the person element remains draggable
              personElement.draggable = true;
              personElement.addEventListener('dragstart', handleDragStart);
              personElement.addEventListener('dragend', handlePersonDragEnd);
              
              // Add tooltip to the seat element
              let guestName = personElement.querySelector('.guest-name')?.textContent || 'Unknown Guest';
              guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
              seats[index].setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
              seats[index].title = `${guestName} (Click to edit, drag to move)`;
            }
          });
          
          // Update seat numbers in the assigned guests list
          guestItems.forEach((guestItem, index) => {
            const guestNameSpan = guestItem.querySelector('.guest-name');
            if (guestNameSpan) {
              const currentText = guestNameSpan.textContent;
              const guestName = currentText.replace(/^Seat \d+: /, '');
              guestNameSpan.textContent = `Seat ${index + 1}: ${guestName}`;
              guestItem.dataset.seatIndex = index + 1;
            }
          });
          
          // Update counts
          updateCounts();
        }
      });
    }
    
    // Mobile touch handlers for table reordering
    let tableTouchStartY = 0;
    let tableTouchDragging = false;
    let tableTouchElement = null;
    
    function handleTableTouchStart(e) {
      if (e.touches.length !== 1) return;
      
      const touch = e.touches[0];
      tableTouchStartY = touch.clientY;
      tableTouchDragging = false;
      tableTouchElement = this;
    }
    
    function handleTableTouchMove(e) {
      if (e.touches.length !== 1 || !tableTouchElement) return;
      
      const touch = e.touches[0];
      const deltaY = Math.abs(touch.clientY - tableTouchStartY);
      
      // Increased threshold to 40px for better scrolling vs dragging distinction
      if (!tableTouchDragging && deltaY > 40) {
        tableTouchDragging = true;
        tableTouchElement.classList.add('dragging');
        tableTouchElement.style.opacity = '0.7';
        tableTouchElement.style.transform = 'scale(1.02)';
      }
      
      if (tableTouchDragging) {
        // Find the element under the touch point
        const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
        const targetTableDiv = elementUnderTouch?.closest('.table-assignment');
        
        if (targetTableDiv && targetTableDiv !== tableTouchElement) {
          // Remove previous highlights
          document.querySelectorAll('.table-assignment.drag-over').forEach(item => {
            item.classList.remove('drag-over');
          });
          
          targetTableDiv.classList.add('drag-over');
        }
      }
    }
    
    function handleTableTouchEnd(e) {
      if (!tableTouchDragging || !tableTouchElement) {
        tableTouchDragging = false;
        tableTouchElement = null;
        return;
      }
      
      const touch = e.changedTouches[0];
      const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
      const targetTableDiv = elementUnderTouch?.closest('.table-assignment');
      
      if (targetTableDiv && targetTableDiv !== tableTouchElement) {
        // Perform the reorder
        const container = document.getElementById('assigned-guests-list');
        const allTables = Array.from(container.querySelectorAll('.table-assignment'));
        const draggedIndex = allTables.indexOf(tableTouchElement);
        const dropIndex = allTables.indexOf(targetTableDiv);
        
        if (draggedIndex !== -1 && dropIndex !== -1) {
          if (draggedIndex < dropIndex) {
            // Moving down
            targetTableDiv.parentNode.insertBefore(tableTouchElement, targetTableDiv.nextSibling);
          } else {
            // Moving up
            targetTableDiv.parentNode.insertBefore(tableTouchElement, targetTableDiv);
          }
        }
      }
      
      // Clean up
      tableTouchElement.classList.remove('dragging');
      tableTouchElement.style.opacity = '';
      tableTouchElement.style.transform = '';
      tableTouchDragging = false;
      tableTouchElement = null;
      
      // Remove all highlights
      document.querySelectorAll('.table-assignment.drag-over').forEach(item => {
        item.classList.remove('drag-over');
      });
    }
    
    // Mobile touch handlers for guest reordering
    let guestTouchStartY = 0;
    let guestTouchDragging = false;
    let guestTouchElement = null;
    
    function handleGuestTouchStart(e) {
      if (e.touches.length !== 1) return;
      
      const touch = e.touches[0];
      guestTouchStartY = touch.clientY;
      guestTouchDragging = false;
      guestTouchElement = this; // This is now the guest item directly
    }
    
    function handleGuestTouchMove(e) {
      if (e.touches.length !== 1 || !guestTouchElement) return;
      
      const touch = e.touches[0];
      const deltaY = Math.abs(touch.clientY - guestTouchStartY);
      
      // Increased threshold to 30px for better scrolling vs dragging distinction
      if (!guestTouchDragging && deltaY > 30) {
        guestTouchDragging = true;
        guestTouchElement.classList.add('dragging');
        guestTouchElement.style.opacity = '0.7';
        guestTouchElement.style.transform = 'scale(1.05)';
      }
      
      if (guestTouchDragging) {
        // Find the element under the touch point
        const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
        const targetGuestItem = elementUnderTouch?.closest('.guest-item');
        
        if (targetGuestItem && targetGuestItem !== guestTouchElement && 
            targetGuestItem.dataset.tableName === guestTouchElement.dataset.tableName) {
          
          // Remove previous highlights
          document.querySelectorAll('.guest-item.drag-over').forEach(item => {
            item.classList.remove('drag-over');
          });
          
          targetGuestItem.classList.add('drag-over');
        }
      }
    }
    
    function handleGuestTouchEnd(e) {
      if (!guestTouchDragging || !guestTouchElement) {
        guestTouchDragging = false;
        guestTouchElement = null;
        return;
      }
      
      const touch = e.changedTouches[0];
      const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
      const targetGuestItem = elementUnderTouch?.closest('.guest-item');
      
      if (targetGuestItem && targetGuestItem !== guestTouchElement && 
          targetGuestItem.dataset.tableName === guestTouchElement.dataset.tableName) {
        
        // Perform the reorder
        const tableContent = targetGuestItem.closest('.table-assignment-content');
        const allGuests = Array.from(tableContent.querySelectorAll('.guest-item:not(.empty-seat-item)'));
        const draggedIndex = allGuests.indexOf(guestTouchElement);
        const dropIndex = allGuests.indexOf(targetGuestItem);
        
        if (draggedIndex !== -1 && dropIndex !== -1) {
          // Reorder in the assigned guests list
          if (draggedIndex < dropIndex) {
            // Moving down
            targetGuestItem.parentNode.insertBefore(guestTouchElement, targetGuestItem.nextSibling);
          } else {
            // Moving up
            targetGuestItem.parentNode.insertBefore(guestTouchElement, targetGuestItem);
          }
          
          // Update the canvas to reflect the new order
          updateCanvasFromAssignedGuestsOrder(tableContent);
        }
      }
      
      // Clean up
      guestTouchElement.classList.remove('dragging');
      guestTouchElement.style.opacity = '';
      guestTouchElement.style.transform = '';
      guestTouchDragging = false;
      guestTouchElement = null;
      
      // Remove all highlights
      document.querySelectorAll('.guest-item.drag-over').forEach(item => {
        item.classList.remove('drag-over');
      });
    }
    
    /* ============================
       Add Guest Button (replaced form)
    ============================ */
    // Note: The add guest functionality is now handled by the "Add New Guest" button
    // which opens the guest profile modal. The event listener is set up earlier in the code.
    
    /* ============================
       Table Handling with Variable Seat Count
    ============================ */
    let tableCounter = 0;
    function createTableContainer(tableId, tableName, tableBodyElem, width, height, tableType, seatCount, leftPos, topPos) {
      // Table container created successfully
      
      const tableContainer = document.createElement('div');
      tableContainer.className = 'table card' + (tableType === "circle" ? " circle" : "");
      tableContainer.id = tableId;
      tableContainer.style.position = 'absolute';
      if (leftPos !== undefined && topPos !== undefined) {
        tableContainer.style.left = leftPos;
        tableContainer.style.top = topPos;
      } else {
        tableContainer.style.left = (50 + (tableCounter * 20)) + 'px';
        tableContainer.style.top = (50 + (tableCounter * 20)) + 'px';
      }
      tableContainer.style.width = (width + 20) + 'px';
      tableContainer.dataset.tableType = tableType;
      tableContainer.dataset.width = width;
      tableContainer.dataset.height = height;
      tableContainer.dataset.seatCount = seatCount;
      
      const header = document.createElement('div');
      header.className = 'card-header table-header d-flex';
      if (tableType === "circle") {
        const nameDiv = document.createElement('div');
        nameDiv.className = 'table-name';
        nameDiv.textContent = tableName;
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'header-controls mt-1';
        const renameBtn = document.createElement('button');
        renameBtn.className = 'btn btn-sm btn-secondary';
        renameBtn.textContent = 'Rename';
        renameBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const newName = prompt('Enter new table name:', nameDiv.textContent);
          if (newName) { nameDiv.textContent = newName; }
        });
        controlsDiv.appendChild(renameBtn);
        const editSeatsBtn = document.createElement('button');
        editSeatsBtn.className = 'btn btn-sm btn-info';
        editSeatsBtn.textContent = 'Edit Seats';
        editSeatsBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const currentCount = parseInt(tableContainer.dataset.seatCount);
          const newCount = parseInt(prompt('Enter new number of seats (minimum 1):', currentCount));
          if (isNaN(newCount) || newCount < 1) return;
          
          // Check if reducing seats will unassign guests
          const currentSeats = tableContainer.querySelectorAll('.card-body .seat');
          const assignedGuests = Array.from(currentSeats).filter(seat => seat.children.length > 0);
          
          if (newCount < assignedGuests.length) {
            const unassignedCount = assignedGuests.length - newCount;
            const tableName = tableContainer.querySelector('.table-name')?.textContent || 'this table';
            if (!confirm(`Warning: Reducing seats from ${currentCount} to ${newCount} will unassign ${unassignedCount} guest(s) from ${tableName}. Continue?`)) {
              return;
            }
          }
          
          updateTableSeats(tableContainer, newCount);
        });
        controlsDiv.appendChild(editSeatsBtn);
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-sm btn-danger';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (confirm('Are you sure you want to remove this table?')) {
            const seats = tableContainer.querySelectorAll('.seat');
            seats.forEach(seat => {
              if (seat.children.length > 0) {
                document.getElementById('people-list').appendChild(seat.children[0]);
              }
            });
            tableContainer.remove();
            updateCounts();
          }
        });
        controlsDiv.appendChild(removeBtn);
        header.appendChild(nameDiv);
        header.appendChild(controlsDiv);
      } else {
        // Creating rectangle table header
        const titleSpan = document.createElement('span');
        titleSpan.className = 'table-title';
        titleSpan.textContent = tableName;
        header.appendChild(titleSpan);
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'header-controls ms-auto';
        const renameBtn = document.createElement('button');
        renameBtn.className = 'btn btn-sm btn-secondary';
        renameBtn.textContent = 'Rename';
        renameBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const newName = prompt('Enter new table name:', titleSpan.textContent);
          if (newName) { titleSpan.textContent = newName; }
        });
        controlsDiv.appendChild(renameBtn);
        const editSeatsBtn = document.createElement('button');
        editSeatsBtn.className = 'btn btn-sm btn-info ms-1';
        editSeatsBtn.textContent = 'Edit Seats';
        editSeatsBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          const currentCount = parseInt(tableContainer.dataset.seatCount);
          const newCount = parseInt(prompt('Enter new number of seats (minimum 1):', currentCount));
          if (isNaN(newCount) || newCount < 1) return;
          
          // Check if reducing seats will unassign guests
          const currentSeats = tableContainer.querySelectorAll('.card-body .seat');
          const assignedGuests = Array.from(currentSeats).filter(seat => seat.children.length > 0);
          
          if (newCount < assignedGuests.length) {
            const unassignedCount = assignedGuests.length - newCount;
            const tableName = tableContainer.querySelector('.table-title')?.textContent || 'this table';
            if (!confirm(`Warning: Reducing seats from ${currentCount} to ${newCount} will unassign ${unassignedCount} guest(s) from ${tableName}. Continue?`)) {
              return;
            }
          }
          
          updateTableSeats(tableContainer, newCount);
        });
        controlsDiv.appendChild(editSeatsBtn);
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-sm btn-danger ms-1';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (confirm('Are you sure you want to remove this table?')) {
            const seats = tableContainer.querySelectorAll('.seat');
            seats.forEach(seat => {
              if (seat.children.length > 0) {
                document.getElementById('people-list').appendChild(seat.children[0]);
              }
            });
            tableContainer.remove();
            updateCounts();
          }
        });
        controlsDiv.appendChild(removeBtn);
        header.appendChild(controlsDiv);
      }
      
      tableContainer.appendChild(header);
      tableContainer.appendChild(tableBodyElem);
      document.getElementById('canvas').appendChild(tableContainer);
      makeTableDraggable(tableContainer);
      tableCounter++;
      updateCounts();
    }
    
    function createCircleTable(tableId, tableName, seatCount, imported = false, leftPos, topPos) {
      const width = 200, height = 200;
      const tableBody = document.createElement('div');
      tableBody.className = 'card-body table-body';
      tableBody.style.position = 'relative';
      tableBody.style.width = width + 'px';
      tableBody.style.height = height + 'px';
      tableBody.style.border = '2px solid #333';
      tableBody.style.borderRadius = '50%';
      tableBody.style.margin = '0px';
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = width / 2 - 20; // keep seats inside border

      for (let i = 0; i < seatCount; i++) {
        const angle = (2 * Math.PI / seatCount) * i;
        const seat = document.createElement('div');
        seat.className = 'seat';
        seat.style.left = (centerX + radius * Math.cos(angle) - 20) + 'px';
        seat.style.top = (centerY + radius * Math.sin(angle) - 20) + 'px';
        seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
        seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
        seat.addEventListener('drop', window.dragDropModule.handleDrop);
        seat.addEventListener('click', function(e) {
          e.stopPropagation();
          openAssignmentModal(seat);
        });
        tableBody.appendChild(seat);
      }
      createTableContainer(tableId, tableName, tableBody, width, height, "circle", seatCount, leftPos, topPos);
    }
    
    function createRectangleTable(tableId, tableName, seatCount, imported = false, leftPos, topPos) {
      const width = 300, height = 150;
      const tableBody = document.createElement('div');
      tableBody.className = 'card-body table-body';
      tableBody.style.position = 'relative';
      tableBody.style.width = width + 'px';
      tableBody.style.height = height + 'px';
      tableBody.style.border = '2px solid #333';
      tableBody.style.borderRadius = '5px';
      tableBody.style.margin = '0px';
      tableBody.style.boxSizing = 'border-box';
      
      // For rectangle tables, distribute seats evenly around the perimeter
      // Use a simple approach: calculate positions based on perimeter distance
      const perimeter = 2 * (width + height);
      const seatSpacing = perimeter / seatCount;
      
      // Create exactly the requested number of seats
      for (let i = 0; i < seatCount; i++) {
        const seat = document.createElement('div');
        seat.className = 'seat';
        
        // Calculate position along the perimeter
        const distance = i * seatSpacing;
        let x, y;
        
        if (distance < width) {
          // Top edge
          x = distance;
          y = 0;
        } else if (distance < width + height) {
          // Right edge
          x = width;
          y = distance - width;
        } else if (distance < 2 * width + height) {
          // Bottom edge
          x = width - (distance - (width + height));
          y = height;
        } else {
          // Left edge
          x = 0;
          y = height - (distance - (2 * width + height));
        }
        
        seat.style.left = (x - 20) + 'px';
        seat.style.top = (y - 20) + 'px';
        
        seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
        seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
        seat.addEventListener('drop', window.dragDropModule.handleDrop);
        seat.addEventListener('click', function(e) {
          e.stopPropagation();
          openAssignmentModal(seat);
        });
        tableBody.appendChild(seat);
      }
      
      createTableContainer(tableId, tableName, tableBody, width, height, "rectangle", seatCount, leftPos, topPos);
    }
    
    function createLongRectangleTable(tableId, tableName, seatCount, imported = false, leftPos, topPos) {
      const width = 600, height = 120; // Much longer and shorter for Last Supper style
      const tableBody = document.createElement('div');
      tableBody.className = 'card-body table-body';
      tableBody.style.position = 'relative';
      tableBody.style.width = width + 'px';
      tableBody.style.height = height + 'px';
      tableBody.style.border = '2px solid #333';
      tableBody.style.borderRadius = '5px';
      tableBody.style.margin = '0px';
      tableBody.style.boxSizing = 'border-box';
      
      // For long rectangle tables, place all seats on one side (top edge)
      const seatSpacing = width / (seatCount + 1); // +1 to avoid edges
      
      // Create exactly the requested number of seats
      for (let i = 0; i < seatCount; i++) {
        const seat = document.createElement('div');
        seat.className = 'seat';
        
        // Calculate position along the top edge
        const x = seatSpacing * (i + 1); // +1 to start after the first spacing
        const y = 0; // All seats on the top edge
        
        seat.style.left = (x - 20) + 'px';
        seat.style.top = (y - 20) + 'px';
        
        seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
        seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
        seat.addEventListener('drop', window.dragDropModule.handleDrop);
        seat.addEventListener('click', function(e) {
          e.stopPropagation();
          openAssignmentModal(seat);
        });
        tableBody.appendChild(seat);
      }
      
      createTableContainer(tableId, tableName, tableBody, width, height, "rectangle-long", seatCount, leftPos, topPos);
    }
    
    function makeTableDraggable(tableElem) {
      const header = tableElem.querySelector('.table-header');
      header.style.cursor = 'move';
      header.addEventListener('mousedown', function(e) {
        if (e.button !== 0) return;
        let offsetX = e.clientX - tableElem.offsetLeft;
        let offsetY = e.clientY - tableElem.offsetTop;
        function mouseMoveHandler(e) {
          tableElem.style.left = (e.clientX - offsetX) + 'px';
          tableElem.style.top = (e.clientY - offsetY) + 'px';
        }
        function mouseUpHandler(e) {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
        }
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler);
      });
    }
    
    function updateTableSeats(tableContainer, newSeatCount) {
      const tableType = tableContainer.dataset.tableType;
      const width = parseInt(tableContainer.dataset.width);
      const height = parseInt(tableContainer.dataset.height);
      const oldAssigned = [];
      const oldSeats = tableContainer.querySelectorAll('.card-body .seat');
      oldSeats.forEach(seat => {
        if (seat.children.length > 0) {
          oldAssigned.push(seat.children[0]);
        }
      });
      const oldBody = tableContainer.querySelector('.card-body');
      oldBody.remove();
      let newBody;
      if (tableType === "circle") {
        newBody = document.createElement('div');
        newBody.className = 'card-body table-body';
        newBody.style.position = 'relative';
        newBody.style.width = width + 'px';
        newBody.style.height = height + 'px';
        newBody.style.border = '2px solid #333';
        newBody.style.borderRadius = '50%';
        newBody.style.margin = '0px';
        newBody.style.boxSizing = 'border-box';
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = width / 2 - 20;
        for (let i = 0; i < newSeatCount; i++) {
          const angle = (2 * Math.PI / newSeatCount) * i;
          const seat = document.createElement('div');
          seat.className = 'seat';
          seat.style.left = (centerX + radius * Math.cos(angle) - 20) + 'px';
          seat.style.top  = (centerY + radius * Math.sin(angle) - 20) + 'px';
          seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
          seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
          seat.addEventListener('drop', window.dragDropModule.handleDrop);
          seat.addEventListener('click', function(e) {
            e.stopPropagation();
            openAssignmentModal(seat);
          });
          newBody.appendChild(seat);
        }
      } else if (tableType === "rectangle") {
        newBody = document.createElement('div');
        newBody.className = 'card-body table-body';
        newBody.style.position = 'relative';
        newBody.style.width = width + 'px';
        newBody.style.height = height + 'px';
        newBody.style.border = '2px solid #333';
        newBody.style.borderRadius = '5px';
        newBody.style.margin = '0px';
        newBody.style.boxSizing = 'border-box';
        
        // For rectangle tables, distribute seats evenly around the perimeter
        // Use a simple approach: calculate positions based on perimeter distance
        const perimeter = 2 * (width + height);
        const seatSpacing = perimeter / newSeatCount;
        
        // Create exactly the requested number of seats
        for (let i = 0; i < newSeatCount; i++) {
          const seat = document.createElement('div');
          seat.className = 'seat';
          
          // Calculate position along the perimeter
          const distance = i * seatSpacing;
          let x, y;
          
          if (distance < width) {
            // Top edge
            x = distance;
            y = 0;
          } else if (distance < width + height) {
            // Right edge
            x = width;
            y = distance - width;
          } else if (distance < 2 * width + height) {
            // Bottom edge
            x = width - (distance - (width + height));
            y = height;
          } else {
            // Left edge
            x = 0;
            y = height - (distance - (2 * width + height));
          }
          
          seat.style.left = (x - 20) + 'px';
          seat.style.top  = (y - 20) + 'px';
          
          seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
          seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
          seat.addEventListener('drop', window.dragDropModule.handleDrop);
          seat.addEventListener('click', function(e) {
            e.stopPropagation();
            openAssignmentModal(seat);
          });
          newBody.appendChild(seat);
        }
      } else if (tableType === "rectangle-long") {
        newBody = document.createElement('div');
        newBody.className = 'card-body table-body';
        newBody.style.position = 'relative';
        newBody.style.width = width + 'px';
        newBody.style.height = height + 'px';
        newBody.style.border = '2px solid #333';
        newBody.style.borderRadius = '5px';
        newBody.style.margin = '0px';
        newBody.style.boxSizing = 'border-box';
        
        // For long rectangle tables, place all seats on one side (top edge)
        const seatSpacing = width / (newSeatCount + 1); // +1 to avoid edges
        
        // Create exactly the requested number of seats
        for (let i = 0; i < newSeatCount; i++) {
          const seat = document.createElement('div');
          seat.className = 'seat';
          
          // Calculate position along the top edge
          const x = seatSpacing * (i + 1); // +1 to start after the first spacing
          const y = 0; // All seats on the top edge
          
          seat.style.left = (x - 20) + 'px';
          seat.style.top = (y - 20) + 'px';
          
          seat.addEventListener('dragover', window.dragDropModule.handleDragOver);
          seat.addEventListener('dragleave', window.dragDropModule.handleDragLeave);
          seat.addEventListener('drop', window.dragDropModule.handleDrop);
          seat.addEventListener('click', function(e) {
            e.stopPropagation();
            openAssignmentModal(seat);
          });
          newBody.appendChild(seat);
        }
      }
      const newSeats = newBody.children;
      const assignCount = Math.min(oldAssigned.length, newSeatCount);
      
      // Reassign guests to new seats and update tooltips
      for (let i = 0; i < assignCount; i++) {
         newSeats[i].innerHTML = '';
         newSeats[i].appendChild(oldAssigned[i]);
         newSeats[i].classList.add('filled');
         
         // Clean guest name and update tooltip
         if (window.cleanGuestName) {
           window.cleanGuestName(oldAssigned[i]);
         }
         let guestName = oldAssigned[i].querySelector('.guest-name')?.textContent || 'Unknown Guest';
         guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
         newSeats[i].setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
         newSeats[i].title = `${guestName} (Click to edit, drag to move)`;
      }
      
      // Move excess guests to unassigned list
      for (let i = assignCount; i < oldAssigned.length; i++) {
         // Clean guest name before moving to unassigned
         if (window.cleanGuestName) {
           window.cleanGuestName(oldAssigned[i]);
         }
         document.getElementById('people-list').appendChild(oldAssigned[i]);
      }
      
      tableContainer.appendChild(newBody);
      tableContainer.dataset.seatCount = newSeatCount;
      
      // Update counts and assigned guests display
      updateCounts();
    }
    
    /* ============================
       Assignment Modal Handling
    ============================ */
    let currentSeat = null;
    function openAssignmentModal(seat) {
      currentSeat = seat;
      document.getElementById('clearSeatBtn').style.display = seat.children.length > 0 ? 'inline-block' : 'none';
      document.getElementById('assignmentSearch').value = '';
      refreshAssignmentModalList();
      const modalEl = document.getElementById('assignmentModal');
      const modal = new bootstrap.Modal(modalEl);
      modal.show();
    }
    function refreshAssignmentModalList() {
      const searchQuery = document.getElementById('assignmentSearch').value.toLowerCase();
      const assignmentList = document.getElementById('assignmentList');
      assignmentList.innerHTML = '';
      const availablePersons = Array.from(document.querySelectorAll("#people-list .person"));
      availablePersons.forEach(person => {
        if (person.textContent.toLowerCase().includes(searchQuery)) {
          const li = document.createElement('li');
          li.className = 'list-group-item list-group-item-action';
          
          // Create a clean version without edit buttons for the modal
          const nameSpan = person.querySelector('.guest-name');
          const guestName = nameSpan ? nameSpan.textContent.replace(/[âœŽâœ–]/g, '').trim() : 'Unknown Guest';
          
          li.innerHTML = `
            <span class="person-icon">ðŸ‘¤</span>
            <span class="guest-name">${guestName}</span>
          `;
          
          li.addEventListener('click', function(e) {
            // Don't trigger if clicking on edit buttons
            if (e.target.classList.contains('edit-guest-btn') || e.target.classList.contains('remove-guest-btn')) {
              return;
            }
            assignPersonToSeat(person, currentSeat);
          });
          assignmentList.appendChild(li);
        }
      });
    }
    function assignPersonToSeat(person, seat) {
      // Clean the guest name first
      cleanGuestName(person);
      
      if (seat.children.length > 0) {
        const existing = seat.children[0];
        document.getElementById('people-list').appendChild(existing);
      }
      const source = person.parentElement;
      if (source && source.classList.contains('seat')) {
        source.classList.remove('filled');
      }
      seat.innerHTML = '';
      seat.appendChild(person);
      seat.classList.add('filled');
      
      // Ensure the person element remains draggable
      person.draggable = true;
      person.addEventListener('dragstart', handleDragStart);
      person.addEventListener('dragend', handlePersonDragEnd);
      
      // Add tooltip to the seat element
      let guestName = person.querySelector('.guest-name')?.textContent || 'Unknown Guest';
      guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
      seat.setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
      seat.title = `${guestName} (Click to edit, drag to move)`;
      
      const modalEl = document.getElementById('assignmentModal');
      const modal = bootstrap.Modal.getInstance(modalEl);
      modal.hide();
      updateCounts();
    }
    function clearSeatAssignment() {
      if (currentSeat && currentSeat.children.length > 0) {
        const person = currentSeat.children[0];
        document.getElementById('people-list').appendChild(person);
        currentSeat.innerHTML = '';
        currentSeat.classList.remove('filled');
        // Clear tooltip and title from the seat
        currentSeat.removeAttribute('data-tooltip');
        currentSeat.removeAttribute('title');
      }
      const modalEl = document.getElementById('assignmentModal');
      const modal = bootstrap.Modal.getInstance(modalEl);
      modal.hide();
      updateCounts();
    }
    document.getElementById('assignmentSearch').addEventListener('input', refreshAssignmentModalList);
    document.getElementById('clearSeatBtn').addEventListener('click', clearSeatAssignment);
    
    /* ============================
       Random Assignment
    ============================ */
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
         const j = Math.floor(Math.random() * (i + 1));
         [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    function randomAssign() {
      let unassignedPeople = Array.from(document.querySelectorAll("#people-list .person"));
      unassignedPeople = shuffleArray(unassignedPeople);
      // Only select seats that are actually part of tables, not orphaned seats
      let emptySeats = Array.from(document.querySelectorAll("#canvas .table.card .card-body .seat")).filter(seat => seat.children.length === 0);
      emptySeats = shuffleArray(emptySeats);
      const assignCount = Math.min(unassignedPeople.length, emptySeats.length);
      for (let i = 0; i < assignCount; i++) {
        const seat = emptySeats[i];
        const person = unassignedPeople[i];
        seat.appendChild(person);
        seat.classList.add('filled');
        
        // Add tooltip to the seat element
        let guestName = person.querySelector('.guest-name')?.textContent || 'Unknown Guest';
        guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
        seat.setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
        seat.title = `${guestName} (Click to edit, drag to move)`;
      }
      updateCounts();
    }
    document.getElementById('randomAssignBtn').addEventListener('click', randomAssign);
    
    /* ============================
       Export / Import State as JSON
    ============================ */
    function getState() {
      const state = { 
        tables: [], 
        unassigned: [],
        guestData: Array.from(guestData.values())
      };
      
      const tableElements = document.querySelectorAll("#canvas .table.card");
      tableElements.forEach(table => {
         const tableName = table.querySelector(".table-title")?.textContent || table.querySelector(".table-name").textContent;
         const tableType = table.dataset.tableType || "";
         const left = table.style.left;
         const top = table.style.top;
         const width = table.dataset.width;
         const height = table.dataset.height;
         const seatCount = table.dataset.seatCount;
         const seats = [];
         const seatElements = table.querySelectorAll(".card-body .seat");
         seatElements.forEach((seat, index) => {
            let guest = "";
            let guestId = "";
            if (seat.children.length > 0) {
                const personElement = seat.children[0];
                guest = personElement.querySelector('.guest-name')?.textContent.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim() || "";
                guestId = personElement.id || "";
            }
            seats.push({ seatIndex: index + 1, guest: guest, guestId: guestId });
         });
         state.tables.push({ tableName, tableType, left, top, width, height, seatCount, seats });
      });
      
      // Add unassigned guests (for backward compatibility)
      const unassignedElements = document.querySelectorAll("#people-list .person");
unassignedElements.forEach(person => {
   const guest = person.querySelector('.guest-name').textContent.trim();
   state.unassigned.push(guest);
});

      return state;
    }
    function exportState() {
      const state = getState();
      const jsonString = JSON.stringify(state, null, 2);
      const blob = new Blob([jsonString], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "table_state.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
    document.getElementById('exportStateBtn').addEventListener('click', exportState);
    function importState(jsonText) {
      const state = JSON.parse(jsonText);
      document.getElementById('canvas').innerHTML = "";
      document.getElementById('people-list').innerHTML = "";
      
      // Clear existing guest data
      guestData.clear();
      guestDataByName.clear();
      personCounter = 0;
      
      // Create a map to store guest data by name for linking
      const guestMap = new Map();
      
      // Import guest data if available (new format)
      if (state.guestData && Array.isArray(state.guestData)) {
        state.guestData.forEach(guest => {
          // Clean the guest name to remove any dietary symbols
          const cleanGuestName = guest.name.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
          const cleanGuest = { ...guest, name: cleanGuestName };
          // Store guest data by ID for proper linking
          guestData.set(guest.id, cleanGuest);
          // Also store by name for backward compatibility
          guestMap.set(cleanGuestName, cleanGuest);
          
          // Populate guestDataByName for duplicate handling
          if (!guestDataByName.has(cleanGuestName)) {
            guestDataByName.set(cleanGuestName, []);
          }
          guestDataByName.get(cleanGuestName).push(cleanGuest);
        });
      }
      
      // Create tables first
      state.tables.forEach(table => {
         const tableId = 'table-' + Date.now() + '-' + Math.random().toString(36).substr(2,5);
         const seatCount = parseInt(table.seatCount);
         if (table.tableType === "circle") {
            createCircleTable(tableId, table.tableName, seatCount, true, table.left, table.top);
         } else if (table.tableType === "rectangle-long") {
            createLongRectangleTable(tableId, table.tableName, seatCount, true, table.left, table.top);
         } else {
            createRectangleTable(tableId, table.tableName, seatCount, true, table.left, table.top);
         }
         const tableContainer = document.getElementById('canvas').lastElementChild;
         const seats = tableContainer.querySelectorAll(".card-body .seat");
         table.seats.forEach(seatData => {
            const idx = seatData.seatIndex - 1;
            if (idx >= 0 && idx < seats.length && seatData.guest) {
               seats[idx].innerHTML = '';
               
               // Try to use guest ID first for proper linking
               let fullGuestData = null;
               if (seatData.guestId && guestData.has(seatData.guestId)) {
                  fullGuestData = guestData.get(seatData.guestId);
               } else {
                  // Fallback to name-based lookup (but handle duplicates)
                  const cleanSeatGuestName = seatData.guest.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
                  const guestsWithSameName = guestDataByName.get(cleanSeatGuestName);
                  if (guestsWithSameName && guestsWithSameName.length > 0) {
                     // For duplicates, we need to be more careful about matching
                     // Try to find the guest that matches the original data best
                     fullGuestData = guestsWithSameName[0]; // Default to first match
                  } else {
                     fullGuestData = guestMap.get(cleanSeatGuestName);
                  }
               }
               
               if (fullGuestData) {
                  // Use the full guest data to create the person element
                  const personElement = createPersonElement(fullGuestData);
                  seats[idx].appendChild(personElement);
               } else {
                  // Fallback to name-only guest (backward compatibility)
                  const cleanSeatGuestName = seatData.guest.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
                  const personElement = createPersonElement(cleanSeatGuestName);
                  seats[idx].appendChild(personElement);
               }
               
               seats[idx].classList.add('filled');
               
               // Add tooltip to the seat element
               let guestName = seats[idx].querySelector('.guest-name')?.textContent || 'Unknown Guest';
               guestName = guestName.replace(/[âœŽâœ–]/g, '').trim();
               seats[idx].setAttribute('data-tooltip', `${guestName} (Click to edit, drag to move)`);
               seats[idx].title = `${guestName} (Click to edit, drag to move)`;
            }
         });
      });
      
      // Import unassigned guests (for backward compatibility with old format)
      if (!state.guestData && state.unassigned) {
      state.unassigned.forEach(guest => {
         addPerson(guest);
      });
      }
      
      updateCounts();
      
      // Update all guest displays to show dietary indicators and other details
      updateAllGuestDisplays();
      
      // Update assigned guests display to show dietary indicators
      updateAssignedGuestsDisplay();
    }
    document.getElementById('importStateBtn').addEventListener('click', function() {
      document.getElementById('importStateFile').click();
    });
    document.getElementById('importStateFile').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
         importState(e.target.result);
      }
      reader.readAsText(file);
    });
    
    /* ============================
       Human-Readable Print Option
    ============================ */
    function printPlan() {
      let html = '<html><head><title>Wedding Seating Plan</title>';
      html += '<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">';
      html += '<style>';
      html += 'body{padding:20px; font-family: Roboto, sans-serif;} ';
      html += 'h1, h2, h3 {margin-top:20px; color: #333;} ';
      html += 'ul {list-style: none; padding: 0;} ';
      html += 'li {margin-bottom: 8px; padding: 8px; border: 1px solid #eee; border-radius: 4px;} ';
      html += '.guest-details {font-size: 0.9em; color: #666; margin-top: 4px;} ';
      html += '.dietary {color: #d63384; font-weight: bold; background: #fff5f5; padding: 2px 6px; border-radius: 3px;} ';
      html += '.plus-one {color: #198754; font-weight: bold; background: #f0fff4; padding: 2px 6px; border-radius: 3px;} ';
      html += '.contact-info {color: #0066cc; font-weight: 500;} ';
      html += '.notes {color: #856404; background: #fff3cd; padding: 4px 8px; border-radius: 3px; font-style: italic;} ';
      html += '.summary-section {background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0;} ';
      html += '.summary-grid {display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;} ';
      html += '.summary-card {background: white; padding: 10px; border-radius: 5px; border-left: 4px solid #007bff;} ';
      html += '</style></head><body>';
      html += '<h1>Wedding Seating Plan</h1>';
      
      // Create comprehensive summary section
      const totalGuests = Array.from(guestData.values()).length;
      const assignedGuests = Array.from(guestData.values()).filter(guest => {
        // Check if guest is assigned to any table
        const tables = document.querySelectorAll('#canvas .table.card');
        for (let table of tables) {
          const seats = table.querySelectorAll('.card-body .seat');
          for (let seat of seats) {
            if (seat.children.length > 0) {
              const seatGuestName = seat.children[0].querySelector('.guest-name')?.textContent.replace(/[âœŽâœ–]/g, '').trim();
              if (seatGuestName === guest.name) {
                return true;
              }
            }
          }
        }
        return false;
      });
      
      const dietaryGuestsSummary = Array.from(guestData.values()).filter(guest => guest.dietary && guest.dietary !== '');
      const plusOneGuests = Array.from(guestData.values()).filter(guest => guest.plusOne === 'Yes');
      const guestsWithNotes = Array.from(guestData.values()).filter(guest => guest.notes && guest.notes.trim() !== '');
      
      html += '<div class="summary-section">';
      html += '<h2>Event Summary</h2>';
      html += '<div class="summary-grid">';
      html += `<div class="summary-card"><strong>Total Guests:</strong> ${totalGuests}</div>`;
      html += `<div class="summary-card"><strong>Assigned to Tables:</strong> ${assignedGuests.length}</div>`;
      html += `<div class="summary-card"><strong>Dietary Requirements:</strong> ${dietaryGuestsSummary.length}</div>`;
      html += `<div class="summary-card"><strong>Plus Ones:</strong> ${plusOneGuests.length}</div>`;
      html += `<div class="summary-card"><strong>Special Notes:</strong> ${guestsWithNotes.length}</div>`;
      html += '</div>';
      html += '</div>';
      
      // Get tables in the order they appear in the assigned guests panel
      const assignedContainer = document.getElementById('assigned-guests-list');
      const tableDivs = assignedContainer.querySelectorAll('.table-assignment');
      
      tableDivs.forEach(tableDiv => {
        const tableName = tableDiv.dataset.tableName;
        const guestItems = tableDiv.querySelectorAll('.guest-item');
        
        if (guestItems.length > 0) {
          html += `<h2>${tableName}</h2>`;
          html += `<p>Seats: ${guestItems.length}</p>`;
  html += '<ul>';
          
          guestItems.forEach(guestItem => {
            const guestNameElement = guestItem.querySelector('.guest-name');
            if (guestNameElement) {
              // Extract only the guest name, excluding any edit buttons and seat number
              let guestName = guestNameElement.textContent;
              // Remove seat number prefix and any edit button text (âœŽ or âœ–) and clean up
              guestName = guestName.replace(/^Seat \d+: /, '').replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
              
              // Use the guest ID from the assigned guests list for accurate lookup
              const guestId = guestItem.dataset.personId;
              let guestDetails = '';
              
              if (guestId && guestData.has(guestId)) {
                const guest = guestData.get(guestId);
                const details = [];
                if (guest.email) details.push(`<span class="contact-info">ðŸ“§ ${guest.email}</span>`);
                if (guest.phone) details.push(`<span class="contact-info">ðŸ“ž ${guest.phone}</span>`);
                if (guest.dietary) details.push(`<span class="dietary">ðŸ¥— ${guest.dietary}</span>`);
                if (guest.plusOne === 'Yes') details.push(`<span class="plus-one">ðŸ‘¥ Plus One</span>`);
                if (guest.notes) details.push(`<span class="notes">ðŸ’¬ ${guest.notes}</span>`);
                
                if (details.length > 0) {
                  guestDetails = `<div class="guest-details">${details.join(' â€¢ ')}</div>`;
                }
              } else {
                // Fallback to name-based lookup for backward compatibility
                for (let [id, guest] of guestData) {
                  if (guest.name === guestName) {
                    const details = [];
                    if (guest.email) details.push(`<span class="contact-info">ðŸ“§ ${guest.email}</span>`);
                    if (guest.phone) details.push(`<span class="contact-info">ðŸ“ž ${guest.phone}</span>`);
                    if (guest.dietary) details.push(`<span class="dietary">ðŸ¥— ${guest.dietary}</span>`);
                    if (guest.plusOne === 'Yes') details.push(`<span class="plus-one">ðŸ‘¥ Plus One</span>`);
                    if (guest.notes) details.push(`<span class="notes">ðŸ’¬ ${guest.notes}</span>`);
                    
                    if (details.length > 0) {
                      guestDetails = `<div class="guest-details">${details.join(' â€¢ ')}</div>`;
                    }
                    break;
                  }
                }
              }
              
              html += `<li>${guestName}${guestDetails}</li>`;
            }
          });
          
  html += '</ul>';
        }
      });
      
      // Get unassigned guests with details
      const unassignedGuests = [];
      const unassignedElements = document.querySelectorAll('#people-list .person');
      unassignedElements.forEach(person => {
        const guestName = person.querySelector('.guest-name')?.textContent || 'Unknown Guest';
        const cleanName = guestName.replace(/[âœŽâœ–ðŸ¥—]/g, '').trim();
        
        // Use the person's ID for accurate guest data lookup
        const guestId = person.id;
        let guestDetails = '';
        
        if (guestId && guestData.has(guestId)) {
          const guest = guestData.get(guestId);
          const details = [];
          if (guest.email) details.push(`<span class="contact-info">ðŸ“§ ${guest.email}</span>`);
          if (guest.phone) details.push(`<span class="contact-info">ðŸ“ž ${guest.phone}</span>`);
          if (guest.dietary) details.push(`<span class="dietary">ðŸ¥— ${guest.dietary}</span>`);
          if (guest.plusOne === 'Yes') details.push(`<span class="plus-one">ðŸ‘¥ Plus One</span>`);
          if (guest.notes) details.push(`<span class="notes">ðŸ’¬ ${guest.notes}</span>`);
          
          if (details.length > 0) {
            guestDetails = `<div class="guest-details">${details.join(' â€¢ ')}</div>`;
          }
        } else {
          // Fallback to name-based lookup for backward compatibility
          for (let [id, guest] of guestData) {
            if (guest.name === cleanName) {
              const details = [];
              if (guest.email) details.push(`<span class="contact-info">ðŸ“§ ${guest.email}</span>`);
              if (guest.phone) details.push(`<span class="contact-info">ðŸ“ž ${guest.phone}</span>`);
              if (guest.dietary) details.push(`<span class="dietary">ðŸ¥— ${guest.dietary}</span>`);
              if (guest.plusOne === 'Yes') details.push(`<span class="plus-one">ðŸ‘¥ Plus One</span>`);
              if (guest.notes) details.push(`<span class="notes">ðŸ’¬ ${guest.notes}</span>`);
              
              if (details.length > 0) {
                guestDetails = `<div class="guest-details">${details.join(' â€¢ ')}</div>`;
              }
              break;
            }
          }
        }
        
        unassignedGuests.push({ name: cleanName, details: guestDetails });
      });
      
      if (unassignedGuests.length > 0) {
         html += '<h2>Unassigned Guests</h2>';
         html += '<ul>';
         unassignedGuests.forEach(guest => {
            html += `<li>${guest.name}${guest.details}</li>`;
         });
         html += '</ul>';
      }
      
      // Add dietary requirements summary
      const dietaryGuests = [];
      for (let [id, guest] of guestData) {
        if (guest.dietary && guest.dietary !== '') {
          dietaryGuests.push({ name: guest.name, dietary: guest.dietary });
        }
      }
      
      if (dietaryGuests.length > 0) {
        html += '<h2>Dietary Requirements Summary</h2>';
        html += '<ul>';
        dietaryGuests.forEach(guest => {
          html += `<li><span class="dietary">${guest.dietary}</span>: ${guest.name}</li>`;
        });
        html += '</ul>';
      }
      
      html += '</body></html>';
      const printWindow = window.open('', '', 'width=800,height=600');
      printWindow.document.write(html);
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
    }
    document.getElementById('printPlanBtn').addEventListener('click', printPlan);
    
    /* ============================
       New Table Modal Form Handling
    ============================ */
    document.getElementById('newTableForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const tableName = document.getElementById('tableName').value.trim();
      const tableType = document.getElementById('tableType').value;
      const seatCount = parseInt(document.getElementById('seatCount').value);
      
              // Creating new table
      
      if (!tableName || isNaN(seatCount) || seatCount < 1) {
        console.log('Validation failed:', { tableName, seatCount });
        return;
      }
      
      const tableId = 'table-' + Date.now();
      if (tableType === 'circle') {
        createCircleTable(tableId, tableName, seatCount);
      } else if (tableType === 'rectangle-long') {
        createLongRectangleTable(tableId, tableName, seatCount);
      } else {
        createRectangleTable(tableId, tableName, seatCount);
      }
      const modalEl = document.getElementById('newTableModal');
      const modal = bootstrap.Modal.getInstance(modalEl);
      modal.hide();
      this.reset();
      
      // Clean up any orphaned seats after table creation
      setTimeout(cleanupOrphanedSeats, 100);
    });
    
    /* ============================
       Cleanup orphaned seats
    ============================ */
    function cleanupOrphanedSeats() {
      // Remove any seats that are not inside table card bodies
      const allSeats = document.querySelectorAll('.seat');
      allSeats.forEach(seat => {
        if (!seat.closest('#canvas .table.card .card-body')) {
          seat.remove();
        }
      });
      
      // Also remove any seats that are direct children of the canvas
      const canvas = document.getElementById('canvas');
      const directSeats = canvas.querySelectorAll(':scope > .seat');
      directSeats.forEach(seat => {
        seat.remove();
      });
    }
    
    /* ============================
       No default tables on load.
    ============================ */
    
    /* ============================
       Collapsible Sidebars
    ============================ */
    function toggleSidebar(sidebarId, toggleId, isLeft = true) {
      const sidebar = document.getElementById(sidebarId);
      const toggle = document.getElementById(toggleId);
      const toggleIcon = toggle.querySelector('.toggle-icon');
      
      if (sidebar.classList.contains('collapsed')) {
        // Expand sidebar
        sidebar.classList.remove('collapsed');
        
        if (isLeft) {
          toggleIcon.textContent = 'â—€';
          toggle.title = 'Collapse sidebar';
        } else {
          toggleIcon.textContent = 'â–¶';
          toggle.title = 'Collapse sidebar';
        }
      } else {
        // Collapse sidebar
        sidebar.classList.add('collapsed');
        
        if (isLeft) {
          toggleIcon.textContent = 'â–¶';
          toggle.title = 'Expand sidebar';
        } else {
          toggleIcon.textContent = 'â—€';
          toggle.title = 'Expand sidebar';
        }
      }
    }
    
    // Add event listeners for sidebar toggles
    document.getElementById('unassigned-toggle').addEventListener('click', function() {
      toggleSidebar('unassigned-sidebar', 'unassigned-toggle', true);
    });
    
    document.getElementById('assigned-toggle').addEventListener('click', function() {
      toggleSidebar('assigned-sidebar', 'assigned-toggle', false);
    });
    
    /* ============================
       Initialize the page
    ============================ */
    // Initialize the assigned guests display on page load
    updateAssignedGuestsDisplay();
    
    // Clean up any orphaned seats on page load
    cleanupOrphanedSeats();
    
    /* ============================
       Real-time Collaboration
    ============================ */
    
    // Collaboration button handler
    document.getElementById('collaborateBtn').addEventListener('click', function() {
      if (!isCollaborating) {
        // Start collaboration
        initCollaboration();
        listenForUpdates();
        
        // Update button
        document.getElementById('collaborateIcon').textContent = 'ðŸŸ¢';
        document.getElementById('collaborateText').textContent = 'Collaborating';
        this.classList.remove('btn-primary');
        this.classList.add('btn-success');
        
        // Show success message
        showCollaborationMessage('Collaboration started! Share this link with your fiancÃ© to work together.', 'success');
        
        // Save current state to Firebase first, then load from Firebase
        const currentState = getState();
        saveToFirebase(currentState);
        
        // Wait a moment for the save to complete, then check Firebase
        setTimeout(() => {
          database.ref('seatingPlan').once('value').then((snapshot) => {
            const data = snapshot.val();
            if (data && data.tables && Object.keys(data.tables).length > 0) {
              // Only load if there's meaningful data in Firebase
              const { lastUpdated, updatedBy, ...cleanData } = data;
              importState(JSON.stringify(cleanData));
              console.log('Loaded existing data from Firebase');
            } else {
              console.log('Firebase is empty, keeping current state');
            }
          }).catch((error) => {
            console.error('Error checking Firebase data:', error);
          });
        }, 500); // Wait 500ms for save to complete
        
      } else {
        // Stop collaboration
        isCollaborating = false;
        if (presenceRef) {
          presenceRef.remove();
        }
        
        // Update button
        document.getElementById('collaborateIcon').textContent = 'ðŸ”—';
        document.getElementById('collaborateText').textContent = 'Start Collaboration';
        this.classList.remove('btn-success');
        this.classList.add('btn-primary');
        
        showCollaborationMessage('Collaboration stopped.', 'info');
      }
    });
    
    // Show collaboration messages
    function showCollaborationMessage(message, type = 'info') {
      // Create message element
      const messageDiv = document.createElement('div');
      messageDiv.className = `alert alert-${type === 'success' ? 'success' : 'info'} alert-dismissible fade show position-fixed`;
      messageDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
      messageDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(messageDiv);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.remove();
        }
      }, 5000);
    }
    
    // Auto-save to Firebase when changes are made
    function autoSaveToFirebase() {
      if (isCollaborating) {
        const state = getState();
        saveToFirebase(state);
      }
    }
    
    // Hook into existing functions to auto-save
    const originalUpdateCounts = updateCounts;
    updateCounts = function() {
      originalUpdateCounts();
      autoSaveToFirebase();
    };
    
    // Hook into guest assignment
    const originalAssignPersonToSeat = assignPersonToSeat;
    assignPersonToSeat = function(person, seat) {
      originalAssignPersonToSeat(person, seat);
      autoSaveToFirebase();
    };
    
    // Hook into table creation
    const originalCreateTableContainer = createTableContainer;
    createTableContainer = function(tableId, tableName, tableBodyElem, width, height, tableType, seatCount, leftPos, topPos) {
      originalCreateTableContainer(tableId, tableName, tableBodyElem, width, height, tableType, seatCount, leftPos, topPos);
      autoSaveToFirebase();
    };
    
    // Hook into guest removal
    const originalClearSeatAssignment = clearSeatAssignment;
    clearSeatAssignment = function() {
      originalClearSeatAssignment();
      autoSaveToFirebase();
    };
    
    // Hook into random assignment
    const originalRandomAssign = randomAssign;
    randomAssign = function() {
      originalRandomAssign();
      autoSaveToFirebase();
    };
    
    // Show online users count
    function updateOnlineUsersDisplay() {
      if (!isCollaborating) return;
      
      getOnlineUsers().then(users => {
        const onlineCount = users.length;
        const collaborateBtn = document.getElementById('collaborateBtn');
        
        if (onlineCount > 1) {
          collaborateBtn.title = `Real-time collaboration active (${onlineCount} users online)`;
          document.getElementById('collaborateText').textContent = `Collaborating (${onlineCount})`;
        } else {
          collaborateBtn.title = 'Real-time collaboration active';
          document.getElementById('collaborateText').textContent = 'Collaborating';
        }
      });
    }
    
    // Update online users display every 10 seconds
    setInterval(updateOnlineUsersDisplay, 10000);
    
  </script>
</body>
</html>
